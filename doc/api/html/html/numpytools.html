

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scitools.numpytools &mdash; SciTools 0.8.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.8.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SciTools 0.8.3 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">SciTools 0.8.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-scitools.numpytools">
<span id="scitools-numpytools"></span><h1><a class="reference internal" href="#module-scitools.numpytools" title="scitools.numpytools"><tt class="xref py py-mod docutils literal"><span class="pre">scitools.numpytools</span></tt></a><a class="headerlink" href="#module-scitools.numpytools" title="Permalink to this headline">¶</a></h1>
<p>Note:
This module stems from the days when there were three (almost) competing
Numerical Python implementations around and people wanted to be able
to switch between these implementations in their Python programs.
Nowadays, numpy is the dominating module, and the use of _numpyload and
numpytools is no longer particularly fruitful. For backward compatibility
of scitools, the two modules still exist.</p>
<div class="section" id="unified-array-computing-interface">
<h2>Unified array computing interface<a class="headerlink" href="#unified-array-computing-interface" title="Permalink to this headline">¶</a></h2>
<p>Numeric, numarray, and numpy can be viewed as three different
implementations of Numerical Python functionality.  The present module
enables writing scripts that are independent of the particular choice
of Numeric, numarray, or numpy. That is, the idea is that any of these
modules can be replaced by one of the alternatives, and the script
should still work. This requires the script to only use the set of
instructions that are common to Numeric, numarray, and numpy.</p>
<p>One reason for wanting the flexibility is that the different
implementations may exhibit different computational efficiency in
different applications. It also makes it trivial to adopt new versions
of Numerical Python in old scripts.</p>
<div class="section" id="basic-usage">
<h3>Basic Usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h3>
<p>To achieve a script that makes transparent use of Numeric, numarray, and
numpy, one needs to do one of the following imports:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitools.numpytools</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c"># or</span>
<span class="kn">import</span> <span class="nn">scitools.numpytools</span> <span class="kn">as</span> <span class="nn">N</span>
</pre></div>
</div>
<p>Then one should never explicitly import Numeric, numarray, or numpy,
and explicitly use functions in these modules as this may cause
different array types to be mixed in the same application. Only call
the functions that were imported by the star or prefix functions by
the N symbol.</p>
</div>
<div class="section" id="what-gets-imported">
<h3>What Gets Imported?<a class="headerlink" href="#what-gets-imported" title="Permalink to this headline">¶</a></h3>
<p>All symbols from either Numeric, numarray, or numpy are imported
into the global namespace of this numpytools module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">Numeric</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c">#or</span>
<span class="kn">from</span> <span class="nn">numarray</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c">#or</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Also the modules for random arrays, linear algebra, Matlab functions,
and FFT are imported. One problem with switching between Numeric,
numarray, and numpy is the additional modules for random arrays, etc.,
have different names in the three packages. For example:</p>
<div class="highlight-python"><pre>Numeric has LinearAlgebra
numarray has numarray.linear_algebra.LinearAlgebra2
numpy has numpy.linalg</pre>
</div>
<p>The Numeric names are always available in addition to the native names.
For example, an import numpy.linalg is associated with a:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">LinearAlgebra</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span>
</pre></div>
</div>
<p>Note that the MA module is not imported since it redefines
the repr function (array([1,2]) becomes [1,2] as for a list) if
the Numeric is used. The user must always explicitly import this package
if Numeric is used as basic array module.</p>
<p>Note that the numpytools module also makes some extensions of Numerical
Python available, see the section &#8220;Functionality of this module that
extends Numerical Python&#8221; (below).</p>
</div>
<div class="section" id="what-to-use-numeric-numarray-or-numpy">
<h3>What to use: Numeric, numarray, or numpy?<a class="headerlink" href="#what-to-use-numeric-numarray-or-numpy" title="Permalink to this headline">¶</a></h3>
<p>The present module defines a global variable basic_NumPy holding
either &#8220;Numeric&#8221;, &#8220;numarray&#8221;, or &#8220;numpy&#8221;, depending on which module
that was actually imported.</p>
<p>To determine whether Numeric, numarray, or numpy is to be imported,
the following procedure is applied:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The command line arguments are checked for a &#8211;numarray,
&#8211;Numeric, or &#8211;numpy option.</p>
</li>
<li><p class="first">If the user has already imported Numeric, numarray, or numpy by an:</p>
<p>import Numeric
#or
import numarray
#or
import numpy</p>
<p>statement, the present module continues to import from the same
module (module in sys.modules is used to check whether it should
be Numeric, numarray, or numpy). If the user has imported more than
one of the three module alternatives, numpy is used.</p>
</li>
<li><p class="first">The environment variable NUMPYARRAY is checked.
If this variable contains &#8220;numarray&#8221;, &#8220;Numeric&#8221;, or &#8220;numpy&#8221; the
corresponding module is imported.</p>
</li>
</ol>
</div></blockquote>
<p>If neither 1., 2., nor 3. determines the import, i.e., the user has not
explicitly indicated what to use, the new numpy is the default choice.</p>
</div>
<div class="section" id="some-functions-for-unified-usage">
<h3>Some Functions for Unified Usage<a class="headerlink" href="#some-functions-for-unified-usage" title="Permalink to this headline">¶</a></h3>
<p>Some operations, like finding the maximum and minimum values in an array,
or controlling the output format when printing arrays, have different
syntax in the different Numerical Python implementations. The functions
below attempt to provide a uniform syntax to functionality with
different names in Numeric, numarray, and numpy:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>NumPyArray:</dt>
<dd><p class="first last">the type used in isinstance(a,NumPyArray) for
checking if a is a NumPy array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>arrmin, arrmax:</dt>
<dd><p class="first last">compute maximum and minimum of all array entries
(same as amin(a,None) and amax(a,None) in scipy)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>array_output_precision(n):</dt>
<dd><p class="first last">print arrays with n decimals</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NumPy_type:</dt>
<dd><p class="first last">returns the type of an array, i.e., &#8220;Numeric&#8221;, &#8220;numarray&#8221;,
or &#8220;numpy&#8221;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NumPy_dtype:</dt>
<dd><p class="first last">returns the type of the data in an array, i.e., &#8216;d&#8217;, &#8216;i&#8217;, etc.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fortran_storage:</dt>
<dd><p class="first last">transparent transform of an array to column major (Fortran) storage
that preserves the nature (Numeric, numarray, numpy) of the array</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Some frequently standard modules like sys, os, and operator are
imported into the namespace of the present module.</p>
</div>
<div class="section" id="example-on-what-gets-imported">
<h3>Example on what gets imported<a class="headerlink" href="#example-on-what-gets-imported" title="Permalink to this headline">¶</a></h3>
<p>(basic_NumPy holds the name of the Numeric
Python module after import of numpytools (or _numpyload):</p>
<p># default:
unix/DOS&gt; python -c &#8220;from numpytools import <a href="#id1"><span class="problematic" id="id2">*</span></a>; print basic_NumPy&#8221;
numpy</p>
<p># set the NUMPYARRAY environment variable:
unix/DOS&gt; python -c &#8220;import os; os.environ[&#8216;NUMPYARRAY&#8217;]=&#8217;Numeric&#8217;; from numpytools import <a href="#id3"><span class="problematic" id="id4">*</span></a>; print basic_NumPy&#8221;
Numeric</p>
<p># import a Numerical Python module (precedence over NUMPYARRAY variable):
unix/DOS&gt; python -c &#8220;import numpy; import os; os.environ[&#8216;NUMPYARRAY&#8217;]=&#8217;Numeric&#8217;; from numpytools import <a href="#id5"><span class="problematic" id="id6">*</span></a>; print basic_NumPy&#8221;
numpy</p>
<p># add flag on the command line (precedence over import):
unix/DOS&gt; python -c &#8220;import numpy; import os; os.environ[&#8216;NUMPYARRAY&#8217;]=&#8217;Numeric&#8217;; from numpytools import <a href="#id7"><span class="problematic" id="id8">*</span></a>; print basic_NumPy&#8221; &#8211;numarray
numarray</p>
</div>
</div>
<div class="section" id="functionality-of-this-module-that-extends-numerical-python">
<h2>Functionality of this module that extends Numerical Python<a class="headerlink" href="#functionality-of-this-module-that-extends-numerical-python" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>solve_tridiag_linear_system:</dt>
<dd><p class="first last">returns the solution of a tridiagonal linear system</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>wrap2callable:</dt>
<dd><p class="first last">tool for turning constants, discrete data, string
formulas, function objects, or plain functions
into an object that behaves as a function</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NumPy_array_iterator:</dt>
<dd><p class="first last">allows iterating over all array elements using
a single, standard for loop (for value, index in iterator),
has some additional features compared with numpy.ndenumerate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>asarray_cpwarn:</dt>
<dd><p class="first last">as <tt class="docutils literal"><span class="pre">numpy.asarray(a)</span></tt>, but a warning or exception is issued if
the array a is copied</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>meshgrid:</dt>
<dd><p class="first last">extended version of <tt class="docutils literal"><span class="pre">numpy.meshgrid</span></tt> to 1D, 2D and 3D grids,
with sparse or dense coordinate arrays and matrix or grid
indexing</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ndgrid:</dt>
<dd><p class="first last">same as calling <tt class="docutils literal"><span class="pre">meshgrid</span></tt> with indexing=&#8217;ij&#8217; (matrix indexing)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>float_eq:</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">operator</span> <span class="pre">==</span></tt> for float operands with tolerance,
<tt class="docutils literal"><span class="pre">float_eq(a,b,tol)</span></tt> means <tt class="docutils literal"><span class="pre">abs(a-b)</span> <span class="pre">&lt;</span> <span class="pre">tol</span></tt>
works for both scalar and array arguments
(similar functions for other operations exists:
<tt class="docutils literal"><span class="pre">float_le</span></tt>, <tt class="docutils literal"><span class="pre">float_lt</span></tt>, <tt class="docutils literal"><span class="pre">float_ge</span></tt>, <tt class="docutils literal"><span class="pre">float_gt</span></tt>,
<tt class="docutils literal"><span class="pre">float_ne</span></tt>)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cut_noise:</dt>
<dd><p class="first last">set all small (noise) elements of an array to zero</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>matrix_rank:</dt>
<dd><p class="first last">compute the rank of a matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>orth:</dt>
<dd><p class="first last">compute an orthonormal basis from a matrix (taken from
<tt class="docutils literal"><span class="pre">scipy.linalg</span></tt> to avoid <tt class="docutils literal"><span class="pre">scipy</span></tt> dependence)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>null:</dt>
<dd><p class="first last">compute the null space of a matrix</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>norm_L2, norm_l2, norm_L1, norm_l1, norm_inf:</dt>
<dd><p class="first last">discrete and continuous norms for multi-dimensional arrays
viewed as vectors</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>compute_historgram:</dt>
<dd><p class="first last">return x and y arrays of a histogram, given a vector of samples</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>seq:</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">seq(a,b,s,</span> <span class="pre">[type])</span></tt> computes numbers from <tt class="docutils literal"><span class="pre">a</span></tt> up to and
including <tt class="docutils literal"><span class="pre">b</span></tt> in steps of s and (default) type <tt class="docutils literal"><span class="pre">float_</span></tt>;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iseq:</dt>
<dd><p class="first last">as <tt class="docutils literal"><span class="pre">seq</span></tt>, but integer counters are computed
(<tt class="docutils literal"><span class="pre">iseq</span></tt> is an alternative to range where the
upper limit is included in the sequence - this can
be important for direct mapping of indices between
mathematics and Python code);</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="scitools.numpytools.Gram_Schmidt">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">Gram_Schmidt</tt><big>(</big><em>vecs</em>, <em>row_wise_storage=True</em>, <em>tol=1e-10</em>, <em>normalize=False</em>, <em>remove_null_vectors=False</em>, <em>remove_noise=False</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#Gram_Schmidt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.Gram_Schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Gram-Schmidt orthogonalization algorithm to a set
of vectors. vecs is a two-dimensional array where the vectors
are stored row-wise, or vecs may be a list of vectors, where
each vector can be a list or a one-dimensional array.</p>
<p>The argument tol is a tolerance for null vectors (the absolute
value of all elements must be less than tol to have a null
vector).</p>
<p>If normalize is True, the orthogonal vectors are normalized to form
an orthonormal basis.</p>
<p>If remove_null_vectors is True, all null vectors are removed from
the resulting basis.</p>
<p>If remove_noise is True, all elements whose absolute values are
less than tol are set to zero.</p>
<p>An array basis is returned, where basis[i,:] (row_wise_storage
is True) or basis[:,i] (row_wise_storage is False) is the i-th
orthogonal vector in the basis.</p>
<p>This function handles null vectors, see Gram_Schmidt1
for a (faster) function that does not.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.Gram_Schmidt1">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">Gram_Schmidt1</tt><big>(</big><em>vecs</em>, <em>row_wise_storage=True</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#Gram_Schmidt1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.Gram_Schmidt1" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Gram-Schmidt orthogonalization algorithm to a set
of vectors. vecs is a two-dimensional array where the vectors
are stored row-wise, or vecs may be a list of vectors, where
each vector can be a list or a one-dimensional array.
An array basis is returned, where basis[i,:] (row_wise_storage
is True) or basis[:,i] (row_wise_storage is False) is the i-th
orthonormal vector in the basis.</p>
<p>This function does not handle null vectors, see Gram_Schmidt
for a (slower) function that does.</p>
</dd></dl>

<dl class="class">
<dt id="scitools.numpytools.NumPy2BltVector">
<em class="property">class </em><tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy2BltVector</tt><big>(</big><em>array</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#NumPy2BltVector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.NumPy2BltVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">_Pmw.Pmw_1_3.lib.PmwBlt.Vector</span></tt></p>
<p>Copy a NumPy array to a BLT vector:
# a: some NumPy array
b = NumPy2BltVector(a)  # b is BLT vector
g = Pmw.Blt.Graph(someframe)
# send b to g for plotting</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt>(*args)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">blt_sort</span></tt>(*args)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blt_sort_reverse</span></tt>(*args)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">clear</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt>(obj)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">delete</span></tt>(*args)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expr</span></tt>(expression)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">index</span></tt>(value)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">insert</span></tt>(index,&nbsp;value)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">length</span></tt>([newSize])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">range</span></tt>(first[,&nbsp;last])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove</span></tt>(value)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">search</span></tt>(start[,&nbsp;end])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>(list)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt>(*args)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.NumPy_array_iterator">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy_array_iterator</tt><big>(</big><em>a</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#NumPy_array_iterator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.NumPy_array_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all elements in a NumPy array a.
Two return values: a generator function and the code of this function.
The <tt class="docutils literal"><span class="pre">numpy.ndenumerate</span></tt> iterator performs the same iteration over
an array, but <tt class="docutils literal"><span class="pre">NumPy_array_iterator</span></tt> has some additional features
(especially handy for coding finite difference stencils, see next
paragraph).</p>
<p>The keyword arguments specify offsets in the start and stop value
of the index in each dimension. Legal argument names are
<tt class="docutils literal"><span class="pre">offset0_start</span></tt>, <tt class="docutils literal"><span class="pre">offset0_stop</span></tt>, <tt class="docutils literal"><span class="pre">offset1_start</span></tt>,
<tt class="docutils literal"><span class="pre">offset1_stop</span></tt>, etc.  Also <tt class="docutils literal"><span class="pre">offset_start</span></tt> and <tt class="docutils literal"><span class="pre">offset_stop</span></tt>
are legal keyword arguments, these imply the same offset value for
all dimensions.</p>
<p>Another keyword argument is <tt class="docutils literal"><span class="pre">no_value</span></tt>, which can be True or False.
If the value is True, the iterator returns the indices as a tuple,
otherwise (default) the iterator returns a two-tuple consisting of
the value of the array and the corresponding indices (as a tuple).</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>  <span class="n">q</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">NumPy_array_iterator</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">code</span>  <span class="c"># generator function with 3 nested loops:</span>
<span class="go">def nested_loops(a):</span>
<span class="go">    for i0 in xrange(0, a.shape[0]-0):</span>
<span class="go">        for i1 in xrange(0, a.shape[1]-0):</span>
<span class="go">            for i2 in xrange(0, a.shape[2]-0):</span>
<span class="go">                yield a[i0, i1, i2], (i0, i1, i2)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&lt;type &#39;function&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">it</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;a</span><span class="si">%s</span><span class="s"> = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">a(0, 0, 0) = 1</span>
<span class="go">a(0, 0, 1) = 2</span>
<span class="go">a(0, 0, 2) = 3</span>
<span class="go">a(0, 0, 3) = 4</span>
<span class="go">a(0, 1, 0) = 5</span>
<span class="go">a(0, 1, 1) = 6</span>
<span class="go">a(0, 1, 2) = 7</span>
<span class="go">a(0, 1, 3) = 8</span>
<span class="go">a(0, 2, 0) = 9</span>
<span class="go">a(0, 2, 1) = 10</span>
<span class="go">a(0, 2, 2) = 11</span>
<span class="go">a(0, 2, 3) = 12</span>
<span class="go">a(1, 0, 0) = 13</span>
<span class="go">a(1, 0, 1) = 14</span>
<span class="go">a(1, 0, 2) = 15</span>
<span class="go">a(1, 0, 3) = 16</span>
<span class="go">a(1, 1, 0) = 17</span>
<span class="go">a(1, 1, 1) = 18</span>
<span class="go">a(1, 1, 2) = 19</span>
<span class="go">a(1, 1, 3) = 20</span>
<span class="go">a(1, 2, 0) = 21</span>
<span class="go">a(1, 2, 1) = 22</span>
<span class="go">a(1, 2, 2) = 23</span>
<span class="go">a(1, 2, 3) = 24</span>
</pre></div>
</div>
<p>Here is the version where only the indices and no the values
are returned by the iterator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="n">q</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">NumPy_array_iterator</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">no_value</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">code</span>
<span class="go">def nested_loops(a):</span>
<span class="go">    for i0 in xrange(0, a.shape[0]-0):</span>
<span class="go">        for i1 in xrange(0, a.shape[1]-0):</span>
<span class="go">            yield i0, i1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">it</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">print</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
<span class="go">0 0</span>
<span class="go">0 1</span>
<span class="go">0 2</span>
</pre></div>
</div>
<p>Now let us try some offsets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">it</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">NumPy_array_iterator</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">offset1_stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset_start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">code</span>
<span class="go">def nested_loops(a):</span>
<span class="go">    for i0 in xrange(1, a.shape[0]-0):</span>
<span class="go">        for i1 in xrange(1, a.shape[1]-1):</span>
<span class="go">            for i2 in xrange(1, a.shape[2]-0):</span>
<span class="go">                yield a[i0, i1, i2], (i0, i1, i2)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># note: the offsets appear in the xrange arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">it</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;a</span><span class="si">%s</span><span class="s"> = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">a(1, 1, 1) = 18</span>
<span class="go">a(1, 1, 2) = 19</span>
<span class="go">a(1, 1, 3) = 20</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.NumPy_dtype">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy_dtype</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#NumPy_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.NumPy_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;param a: NumPy array
&#64;return:  array data type, as a character,
depending on which module that was
used to generate the a array (a.typecode() for Numeric and
numarray, a.dtype for numpy).</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.NumPy_type">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">NumPy_type</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#NumPy_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.NumPy_type" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;param a: NumPy array
&#64;return:  &#8220;Numeric&#8221;, &#8220;numarray&#8221;, or &#8220;numpy&#8221;, depending on which
module that was used to generate the a array</p>
<p>If type is list or tuple then the corresponding typename will be returned</p>
</dd></dl>

<dl class="class">
<dt id="scitools.numpytools.WrapDiscreteData2Callable">
<em class="property">class </em><tt class="descclassname">scitools.numpytools.</tt><tt class="descname">WrapDiscreteData2Callable</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#WrapDiscreteData2Callable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.WrapDiscreteData2Callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn discrete data on a uniform grid into a callable function,
i.e., equip the data with an interpolation function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">WrapDiscreteData2Callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># or just use the wrap2callable generic function:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>   <span class="c"># evaluate f(x) by interpolation</span>
<span class="go">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>  <span class="c"># discrete data with extra time prm: f(x,t)</span>
<span class="go">1.5</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt>(*args)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="scitools.numpytools.WrapNo2Callable">
<em class="property">class </em><tt class="descclassname">scitools.numpytools.</tt><tt class="descname">WrapNo2Callable</tt><big>(</big><em>constant</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#WrapNo2Callable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.WrapNo2Callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a number (constant) into a callable function.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__call__</span></tt>(*args)</td>
<td><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">WrapNo2Callable</span><span class="p">(</span><span class="mf">4.4</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.arr">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">arr</tt><big>(</big><em>shape=None</em>, <em>element_type=&lt;type 'float'&gt;</em>, <em>interval=None</em>, <em>data=None</em>, <em>copy=True</em>, <em>file_=None</em>, <em>order='C'</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#arr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.arr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compact and flexible interface for creating NumPy arrays,
including several consistency and error checks.</p>
<blockquote>
<div><ul class="simple">
<li><em>shape</em>: length of each dimension, tuple or int</li>
<li><em>data</em>: list, tuple, or NumPy array with data elements</li>
<li><em>copy</em>: copy data if true, share data if false, boolean</li>
<li><em>element_type</em>: float, int, int16, float64, bool, etc.</li>
<li><em>interval</em>: make elements from a to b (shape gives no of elms), tuple or list</li>
<li><em>file_</em>: filename or file object containing array data, string</li>
<li><em>order</em>: &#8216;Fortran&#8217; or &#8216;C&#8217; storage, string</li>
<li>return value: created Numerical Python array</li>
</ul>
</div></blockquote>
<p>The array can be created in four ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li>as zeros (just shape specified),</li>
<li>as uniformly spaced coordinates in an interval [a,b]</li>
<li>as a copy of or reference to (depending on copy=True,False resp.)
a list, tuple, or NumPy array (provided as the data argument),</li>
<li>from data in a file (for one- or two-dimensional real-valued arrays).</li>
</ol>
</div></blockquote>
<p>The function calls the underlying NumPy functions zeros, array and
linspace (see the NumPy manual for the functionality of these
functions).  In case of data in a file, the first line determines
the number of columns in the array. The file format is just rows
and columns with numbers, no decorations (square brackets, commas,
etc.) are allowed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([[ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">element_type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span>  <span class="c"># integer array</span>
<span class="go">array([4, 4, 4, 4])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([ 0.,  1.,  2.])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">somelist</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">somelist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  <span class="c"># a has always float elements by default</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 5.,  5.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">somelist</span><span class="p">,</span> <span class="n">element_type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [5, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>  <span class="c"># let c share data with b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># make a file with array data:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;tmp.dat&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;&#39;&#39;    ... 1 3</span>
<span class="gp">... </span><span class="s">2 6</span>
<span class="gp">... </span><span class="s">3 12</span>
<span class="gp">... </span><span class="s">3.5 20</span>
<span class="gp">... </span><span class="s">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># read array data from file:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">(</span><span class="n">file_</span><span class="o">=</span><span class="s">&#39;tmp.dat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[  1. ,   3. ],</span>
<span class="go">       [  2. ,   6. ],</span>
<span class="go">       [  3. ,  12. ],</span>
<span class="go">       [  3.5,  20. ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.array_output_precision">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">array_output_precision</tt><big>(</big><em>no_of_decimals</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#array_output_precision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.array_output_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Set no of decimals in printout of arrays.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.arrmax">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">arrmax</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#arrmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.arrmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximum of all the entries in a.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.arrmin">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">arrmin</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#arrmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.arrmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum of all the entries in a.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.asarray_cpwarn">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">asarray_cpwarn</tt><big>(</big><em>a</em>, <em>dtype=None</em>, <em>message='warning'</em>, <em>comment=''</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#asarray_cpwarn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.asarray_cpwarn" title="Permalink to this definition">¶</a></dt>
<dd><p>As asarray, but a warning or exception is issued if the
a array is copied.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.compute_histogram">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">compute_histogram</tt><big>(</big><em>samples</em>, <em>nbins=50</em>, <em>piecewise_constant=True</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#compute_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.compute_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a NumPy array samples with random samples, this function
returns the (x,y) arrays in a plot-ready version of the histogram.
If piecewise_constant is True, the (x,y) arrays gives a piecewise
constant curve when plotted, otherwise the (x,y) arrays gives a
piecewise linear curve where the x coordinates coincide with the
center points in each bin. The function makes use of
numpy.lib.function_base.histogram with some additional code
(for a piecewise curve or displaced x values to the centes of
the bins).</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.cut_noise">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">cut_noise</tt><big>(</big><em>a</em>, <em>tol=1e-10</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#cut_noise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.cut_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Set elements in array a to zero if the absolute value is
less than tol.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.factorial">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">factorial</tt><big>(</big><em>n</em>, <em>method='reduce'</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#factorial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.factorial" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the factorial n! using long integers (and pure Python code).
Different implementations are available (see source code for 
implementation details).</p>
<p>Note: The math module in Python 2.6 features a factorial
function, making the present function redundant (except that
the various pure Python implementations can be of interest
for comparison).</p>
<p>Here is an efficiency comparison of the methods (computing 80!):</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head">Normalized CPU time</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>reduce</td>
<td>1.00</td>
</tr>
<tr class="row-odd"><td>lambda list comprehension</td>
<td>1.70</td>
</tr>
<tr class="row-even"><td>lambda functional</td>
<td>3.08</td>
</tr>
<tr class="row-odd"><td>plain recursive</td>
<td>5.83</td>
</tr>
<tr class="row-even"><td>lambda recursive</td>
<td>21.73</td>
</tr>
<tr class="row-odd"><td>scipy</td>
<td>131.18</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.factorize_tridiag_matrix">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">factorize_tridiag_matrix</tt><big>(</big><em>A</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#factorize_tridiag_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.factorize_tridiag_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the factorization step only in solving a tridiagonal
linear system. See the function solve_tridiag_linear_system
for how the matrix <em>A</em> is stored.
Two arrays, <em>c</em> and <em>d</em>, are returned, and these represent,
together with superdiagonal <em>A[:-1,2]</em>, the factorized form of
<em>A</em>. To solve a system with <tt class="docutils literal"><span class="pre">solve_tridiag_factored_system</span></tt>,
<em>A</em>, <em>c</em>, and <em>d</em> must be passed as arguments.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.fortran_storage">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">fortran_storage</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#fortran_storage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.fortran_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Transparent transform of a NumPy array to Fortran (column major)
storage.</p>
<p>&#64;param a:  NumPy array (generated in Python or C with C storage)
&#64;return: a new NumPy array with column major storage.</p>
<p>Method: If a is of numpy type, numpy.asarray(a, fortran=True)
is used to produce the new array.
If a is of Numeric or numarray type, we want to preserve the array type
and use a simple (and slower) transpose(transpose(a).copy()) instead.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.iseq">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">iseq</tt><big>(</big><em>start=0</em>, <em>stop=None</em>, <em>inc=1</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#iseq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.iseq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate integers from start to (and including) stop,
with increment of inc. Alternative to range/xrange.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.isequence">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">isequence</tt><big>(</big><em>start=0</em>, <em>stop=None</em>, <em>inc=1</em><big>)</big><a class="headerlink" href="#scitools.numpytools.isequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate integers from start to (and including) stop,
with increment of inc. Alternative to range/xrange.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.length">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">length</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the largest dimension of array a.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.matrix_rank">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">matrix_rank</tt><big>(</big><em>A</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#matrix_rank"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.matrix_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank of a matrix A (rank means an estimate of
the number of linearly independent rows or columns).</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.meshgrid">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">meshgrid</tt><big>(</big><em>x=None</em>, <em>y=None</em>, <em>z=None</em>, <em>sparse=False</em>, <em>indexing='xy'</em>, <em>memoryorder=None</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#meshgrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Extension of numpy.meshgrid to 1D, 2D and 3D problems, and also
support of both &#8220;matrix&#8221; and &#8220;grid&#8221; numbering.</p>
<p>This extended version makes 1D/2D/3D coordinate arrays for
vectorized evaluations of 1D/2D/3D scalar/vector fields over
1D/2D/3D grids, given one-dimensional coordinate arrays x, y,
and/or, z.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># coordinates along x axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        <span class="c"># coordinates along y axis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>   <span class="c"># extend x and y for a 2D xy grid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ],</span>
<span class="go">       [ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># make sparse output arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># 2D slice of a 3D grid, with z=const:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">zc</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>   
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ],</span>
<span class="go">       [ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zc</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># 2D slice of a 3D grid, with x=const:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>  
<span class="go">(2, array([[ 0.,  1.],</span>
<span class="go">       [ 0.,  1.],</span>
<span class="go">       [ 0.,  1.]]), array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  1. ]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># just a 3D point</span>
<span class="go">(0, 1, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>      <span class="c"># 1D grid; y is just returned</span>
<span class="go">array([ 0.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;ij&#39;</span><span class="p">)</span>  <span class="c"># change to matrix indexing</span>
<span class="go">(array([[ 0. ,  0. ],</span>
<span class="go">       [ 0.5,  0.5],</span>
<span class="go">       [ 1. ,  1. ]]), array([[ 0.,  1.],</span>
<span class="go">       [ 0.,  1.],</span>
<span class="go">       [ 0.,  1.]]))</span>
</pre></div>
</div>
<p>Why does SciTools has its own meshgrid function when NumPy has three
similar functions, <cite>mgrid</cite>, <cite>ogrid</cite>, and <cite>meshgrid</cite>?
The <cite>meshgrid</cite> function in NumPy is limited to two dimensions only, while
the SciTools version can also work with 3D and 1D grids. In addition,
the NumPy version of <cite>meshgrid</cite> has no option for generating sparse
grids to conserve memory, like we have in SciTools by specifying the
<cite>sparse</cite> argument.</p>
<p>The NumPy functions <cite>mgrid</cite> and <cite>ogrid</cite> does provide support for,
respectively, full and sparse n-dimensional meshgrids, however,
these functions uses slices to generate the meshgrids rather than
one-dimensional coordinate arrays such as in Matlab. With slices, the
user does not have the option to generate meshgrid with, e.g.,
irregular spacings, like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[-1. , -0.5,  1. ,  4. ,  5. ], </span>
<span class="go">       [-1. , -0.5,  1. ,  4. ,  5. ], </span>
<span class="go">       [-1. , -0.5,  1. ,  4. ,  5. ]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.], </span>
<span class="go">       [-2., -2., -2., -2., -2.], </span>
<span class="go">       [-5., -5., -5., -5., -5.]])</span>
</pre></div>
</div>
<p>In addition to the reasons mentioned above, the meshgrid function in
NumPy supports only Cartesian indexing, i.e., x and y, not matrix
indexing, i.e., rows and columns (<cite>mgrid</cite> and <cite>ogrid</cite> supports only
matrix indexing). The <cite>meshgrid</cite> function in SciTools supports both
indexing conventions through the <cite>indexing</cite> keyword argument. Giving
the string <cite>&#8216;ij&#8217;</cite> returns a meshgrid with matrix indexing, while
<cite>&#8216;xy&#8217;</cite> returns a meshgrid with Cartesian indexing. The difference is
illustrated by the following code snippet:</p>
<div class="highlight-python"><pre>nx = 10
ny = 15

x = linspace(-2,2,nx)
y = linspace(-2,2,ny)

xv, yv = meshgrid(x, y, sparse=False, indexing='ij')
for i in range(nx):
    for j in range(ny):
        # treat xv[i,j], yv[i,j]

xv, yv = meshgrid(x, y, sparse=False, indexing='xy')
for i in range(nx):
    for j in range(ny):
        # treat xv[j,i], yv[j,i]</pre>
</div>
<p>It is not entirely true that matrix indexing is not supported by the
<cite>meshgrid</cite> function in NumPy because we can just switch the order of
the first two input and output arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span><span class="p">,</span> <span class="n">xv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># same as:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;ij&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>However, we think it is clearer to have the logical &#8220;x, y&#8221;
sequence on the left-hand side and instead adjust a keyword argument.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.ndgrid">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">ndgrid</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#ndgrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.ndgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as calling <tt class="docutils literal"><span class="pre">meshgrid</span></tt> with <em>indexing</em> = <tt class="docutils literal"><span class="pre">'ij'</span></tt> (see
<tt class="docutils literal"><span class="pre">meshgrid</span></tt> for documentation).</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_L1">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_L1</tt><big>(</big><em>u</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#norm_L1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.norm_L1" title="Permalink to this definition">¶</a></dt>
<dd><p>L1 norm of a multi-dimensional array u viewed as a vector:
<tt class="docutils literal"><span class="pre">norm_l1(u)/float(u.size)</span></tt>.</p>
<p>If <em>u</em> holds function values and the norm of u is supposed to
approximate an integral (L1 norm) of the function, this (and
not norm_l1) is the right norm function to use.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_L2">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_L2</tt><big>(</big><em>u</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#norm_L2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.norm_L2" title="Permalink to this definition">¶</a></dt>
<dd><p>L2 norm of a multi-dimensional array u viewed as a vector
(norm is norm_l2/n, where n is length of u (no of elements)).</p>
<p>If u holds function values and the norm of u is supposed to
approximate an integral (L2 norm) of the function, this (and
not norm_l2) is the right norm function to use.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_inf">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_inf</tt><big>(</big><em>u</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#norm_inf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.norm_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>Infinity/max norm of a multi-dimensional array u viewed as a vector.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_l1">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_l1</tt><big>(</big><em>u</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#norm_l1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.norm_l1" title="Permalink to this definition">¶</a></dt>
<dd><p>l1 norm of a multi-dimensional array u viewed as a vector:
<tt class="docutils literal"><span class="pre">linalg.norm(u.ravel(),1)</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.norm_l2">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">norm_l2</tt><big>(</big><em>u</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#norm_l2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.norm_l2" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard l2 norm of a multi-dimensional array u viewed as a vector.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.null">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">null</tt><big>(</big><em>A</em>, <em>tol=1e-10</em>, <em>row_wise_storage=True</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#null"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.null" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the null space of a matrix A.
If row_wise_storage is True, a two-dimensional array where the
vectors that span the null space are stored as rows, otherwise
they are stored as columns.</p>
<p>Code by Bastian Weber based on code by Robert Kern and Ryan Krauss.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.orth">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">orth</tt><big>(</big><em>A</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#orth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>(Plain copy from scipy.linalg.orth - this one here applies numpy.svd
and avoids the need for having scipy installed.)</p>
<p>Construct an orthonormal basis for the range of A using SVD.</p>
<p>&#64;param A: array, shape (M, N)
&#64;return:</p>
<blockquote>
<div>Q : array, shape (M, K)
Orthonormal basis for the range of A.
K = effective rank of A, as determined by automatic cutoff</div></blockquote>
<p>see also svd (singular value decomposition of a matrix in scipy.linalg)</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.seq">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">seq</tt><big>(</big><em>min=0.0</em>, <em>max=None</em>, <em>inc=1.0</em>, <em>type=&lt;type 'float'&gt;</em>, <em>return_type='NumPyArray'</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#seq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate numbers from min to (and including!) max,
with increment of inc. Safe alternative to arange.
The return_type string governs the type of the returned
sequence of numbers (&#8216;NumPyArray&#8217;, &#8216;list&#8217;, or &#8216;tuple&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.sequence">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">sequence</tt><big>(</big><em>min=0.0</em>, <em>max=None</em>, <em>inc=1.0</em>, <em>type=&lt;type 'float'&gt;</em>, <em>return_type='NumPyArray'</em><big>)</big><a class="headerlink" href="#scitools.numpytools.sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate numbers from min to (and including!) max,
with increment of inc. Safe alternative to arange.
The return_type string governs the type of the returned
sequence of numbers (&#8216;NumPyArray&#8217;, &#8216;list&#8217;, or &#8216;tuple&#8217;).</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.solve_tridiag_factored_system">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">solve_tridiag_factored_system</tt><big>(</big><em>b</em>, <em>A</em>, <em>c</em>, <em>d</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#solve_tridiag_factored_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.solve_tridiag_factored_system" title="Permalink to this definition">¶</a></dt>
<dd><p>The backsubsitution part of solving a tridiagonal linear system.
The right-hand side is b, while <em>A</em>, <em>c</em>, and <em>d</em> represent the
factored matrix (see the factorize_tridiag_matrix function).
The solution x to A*x=b is returned.</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.solve_tridiag_linear_system">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">solve_tridiag_linear_system</tt><big>(</big><em>A</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#solve_tridiag_linear_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.solve_tridiag_linear_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an n times n tridiagonal linear system of the form:</p>
<div class="highlight-python"><pre>A[0,1]*x[0] + A[0,2]*x[1]                                        = 0
A[1,0]*x[0] + A[1,1]*x[1] + A[1,2]*x[2]                          = 0
...
...
         A[k,0]*x[k-1] + A[k,1]*x[k] + A[k,2]*x[k+1]             = 0
...
             A[n-2,0]*x[n-3] + A[n-2,1]*x[n-2] + A[n-2,2]*x[n-1] = 0
...
                               A[n-1,0]*x[n-2] + A[n-1,1]*x[n-1] = 0</pre>
</div>
<p>The diagonal of the coefficent matrix is stored in A[:,1],
the subdiagonal is stored in A[1:,0], and the superdiagonal
is stored in A[:-1,2].</p>
</dd></dl>

<dl class="function">
<dt id="scitools.numpytools.wrap2callable">
<tt class="descclassname">scitools.numpytools.</tt><tt class="descname">wrap2callable</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/scitools/numpytools.html#wrap2callable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#scitools.numpytools.wrap2callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow constants, string formulas, discrete data points,
user-defined functions and (callable) classes to be wrapped
in a new callable function. That is, all the mentioned data
structures can be used as a function, usually of space and/or
time.
(kwargs is used for string formulas)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;1+2*x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;1+2*t&#39;</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;a+b*t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;a&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;a+b*t&#39;</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f5</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f6</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f6</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f7</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f7</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
<span class="go">        &#39;Representation of a function f(x; a, b) =a + b*x&#39;</span>
<span class="go">        def __init__(self, a=1, b=1):</span>
<span class="go">            self.a = a;  self.b = b</span>
<span class="go">        def __call__(self, x):</span>
<span class="go">            return self.a + self.b*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myclass</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="n">myclass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># 3D functions:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">(</span><span class="s">&#39;1+2*x+3*y+4*z&#39;</span><span class="p">,</span> <span class="n">independent_variables</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># discrete 3D data:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">z</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zv</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">myfunc3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>  <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">z</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">myfunc3</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">zv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f10</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f10</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>One can also check what the object is wrapped as and do more
specific operations, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f9</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;StringFunction&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">f9</span><span class="p">)</span>     <span class="c"># look at function formula</span>
<span class="go">&#39;1+2*x+3*y+4*z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;MyClass&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f8</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">f8</span><span class="o">.</span><span class="n">b</span>  <span class="c"># access MyClass-specific data</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>Troubleshooting regarding string functions:
If you use a string formula with a NumPy array, you typically get
error messages like:</p>
<div class="highlight-python"><pre>TypeError: only rank-0 arrays can be converted to Python scalars.</pre>
</div>
<p>You must then make the right import (numpy is recommended):</p>
<div class="highlight-python"><pre>from Numeric/numarray/numpy/scitools.numpytools import *</pre>
</div>
<p>in the calling code and supply the keyword argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">globals</span><span class="o">=</span><span class="nb">globals</span><span class="p">()</span>
</pre></div>
</div>
<p>to wrap2callable. See also the documentation of class StringFunction
for more information.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/scitools_logo.jpg" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">scitools.numpytools</span></tt></a><ul>
<li><a class="reference internal" href="#unified-array-computing-interface">Unified array computing interface</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic Usage</a></li>
<li><a class="reference internal" href="#what-gets-imported">What Gets Imported?</a></li>
<li><a class="reference internal" href="#what-to-use-numeric-numarray-or-numpy">What to use: Numeric, numarray, or numpy?</a></li>
<li><a class="reference internal" href="#some-functions-for-unified-usage">Some Functions for Unified Usage</a></li>
<li><a class="reference internal" href="#example-on-what-gets-imported">Example on what gets imported</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functionality-of-this-module-that-extends-numerical-python">Functionality of this module that extends Numerical Python</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/numpytools.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">SciTools 0.8.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, H. P. Langtangen, J. Ring, ++.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>