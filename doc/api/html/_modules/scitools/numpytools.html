

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scitools.numpytools &mdash; SciTools 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SciTools 0.9.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">SciTools 0.9.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for scitools.numpytools</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">%s</span>

<span class="sd">%s</span>
<span class="sd">&quot;&quot;&quot;</span>
    
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">operator</span><span class="o">,</span> <span class="nn">math</span>


<span class="c"># copied into this file by preprocess.py:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Note:</span>
<span class="sd">This module stems from the days when there were three (almost) competing</span>
<span class="sd">Numerical Python implementations around and people wanted to be able</span>
<span class="sd">to switch between these implementations in their Python programs.</span>
<span class="sd">Nowadays, numpy is the dominating module, and the use of _numpyload and</span>
<span class="sd">numpytools is no longer particularly fruitful. For backward compatibility</span>
<span class="sd">of scitools, the two modules still exist.</span>


<span class="sd">Unified array computing interface</span>
<span class="sd">=================================</span>

<span class="sd">Numeric, numarray, and numpy can be viewed as three different</span>
<span class="sd">implementations of Numerical Python functionality.  The present module</span>
<span class="sd">enables writing scripts that are independent of the particular choice</span>
<span class="sd">of Numeric, numarray, or numpy. That is, the idea is that any of these</span>
<span class="sd">modules can be replaced by one of the alternatives, and the script</span>
<span class="sd">should still work. This requires the script to only use the set of</span>
<span class="sd">instructions that are common to Numeric, numarray, and numpy.</span>

<span class="sd">One reason for wanting the flexibility is that the different</span>
<span class="sd">implementations may exhibit different computational efficiency in</span>
<span class="sd">different applications. It also makes it trivial to adopt new versions</span>
<span class="sd">of Numerical Python in old scripts.</span>


<span class="sd">Basic Usage</span>
<span class="sd">-----------</span>

<span class="sd">To achieve a script that makes transparent use of Numeric, numarray, and</span>
<span class="sd">numpy, one needs to do one of the following imports::</span>

<span class="sd">  from scitools.numpytools import *</span>
<span class="sd">  # or</span>
<span class="sd">  import scitools.numpytools as N</span>

<span class="sd">Then one should never explicitly import Numeric, numarray, or numpy,</span>
<span class="sd">and explicitly use functions in these modules as this may cause</span>
<span class="sd">different array types to be mixed in the same application. Only call</span>
<span class="sd">the functions that were imported by the star or prefix functions by</span>
<span class="sd">the N symbol.</span>


<span class="sd">What Gets Imported?</span>
<span class="sd">-------------------</span>

<span class="sd">All symbols from either Numeric, numarray, or numpy are imported</span>
<span class="sd">into the global namespace of this numpytools module::</span>

<span class="sd">  from Numeric import *</span>
<span class="sd">  #or</span>
<span class="sd">  from numarray import *</span>
<span class="sd">  #or</span>
<span class="sd">  from numpy import *</span>

<span class="sd">Also the modules for random arrays, linear algebra, Matlab functions,</span>
<span class="sd">and FFT are imported. One problem with switching between Numeric,</span>
<span class="sd">numarray, and numpy is the additional modules for random arrays, etc.,</span>
<span class="sd">have different names in the three packages. For example::</span>

<span class="sd">  Numeric has LinearAlgebra</span>
<span class="sd">  numarray has numarray.linear_algebra.LinearAlgebra2</span>
<span class="sd">  numpy has numpy.linalg</span>

<span class="sd">The Numeric names are always available in addition to the native names.</span>
<span class="sd">For example, an import numpy.linalg is associated with a::</span>

<span class="sd">  LinearAlgebra = numpy.linalg</span>
<span class="sd">  </span>
<span class="sd">Note that the MA module is not imported since it redefines</span>
<span class="sd">the repr function (array([1,2]) becomes [1,2] as for a list) if</span>
<span class="sd">the Numeric is used. The user must always explicitly import this package</span>
<span class="sd">if Numeric is used as basic array module.</span>

<span class="sd">Note that the numpytools module also makes some extensions of Numerical</span>
<span class="sd">Python available, see the section &quot;Functionality of this module that</span>
<span class="sd">extends Numerical Python&quot; (below).</span>


<span class="sd">What to use: Numeric, numarray, or numpy?</span>
<span class="sd">-----------------------------------------</span>

<span class="sd">The present module defines a global variable basic_NumPy holding</span>
<span class="sd">either &quot;Numeric&quot;, &quot;numarray&quot;, or &quot;numpy&quot;, depending on which module</span>
<span class="sd">that was actually imported.</span>

<span class="sd">To determine whether Numeric, numarray, or numpy is to be imported,</span>
<span class="sd">the following procedure is applied:</span>

<span class="sd">  1. The command line arguments are checked for a --numarray,</span>
<span class="sd">     --Numeric, or --numpy option.</span>
<span class="sd">   </span>
<span class="sd">  2. If the user has already imported Numeric, numarray, or numpy by an::</span>

<span class="sd">     import Numeric</span>
<span class="sd">     #or</span>
<span class="sd">     import numarray</span>
<span class="sd">     #or</span>
<span class="sd">     import numpy</span>

<span class="sd">     statement, the present module continues to import from the same</span>
<span class="sd">     module (module in sys.modules is used to check whether it should</span>
<span class="sd">     be Numeric, numarray, or numpy). If the user has imported more than</span>
<span class="sd">     one of the three module alternatives, numpy is used.</span>
<span class="sd">   </span>
<span class="sd">  3. The environment variable NUMPYARRAY is checked.</span>
<span class="sd">     If this variable contains &quot;numarray&quot;, &quot;Numeric&quot;, or &quot;numpy&quot; the</span>
<span class="sd">     corresponding module is imported.</span>

<span class="sd">If neither 1., 2., nor 3. determines the import, i.e., the user has not</span>
<span class="sd">explicitly indicated what to use, the new numpy is the default choice.</span>

<span class="sd">Some Functions for Unified Usage</span>
<span class="sd">--------------------------------</span>

<span class="sd">Some operations, like finding the maximum and minimum values in an array,</span>
<span class="sd">or controlling the output format when printing arrays, have different</span>
<span class="sd">syntax in the different Numerical Python implementations. The functions</span>
<span class="sd">below attempt to provide a uniform syntax to functionality with</span>
<span class="sd">different names in Numeric, numarray, and numpy:</span>

<span class="sd"> - NumPyArray:</span>
<span class="sd">           the type used in isinstance(a,NumPyArray) for</span>
<span class="sd">           checking if a is a NumPy array</span>

<span class="sd"> - arrmin, arrmax:</span>
<span class="sd">           compute maximum and minimum of all array entries</span>
<span class="sd">           (same as amin(a,None) and amax(a,None) in scipy)</span>

<span class="sd"> - array_output_precision(n):</span>
<span class="sd">           print arrays with n decimals</span>

<span class="sd"> - NumPy_type:</span>
<span class="sd">           returns the type of an array, i.e., &quot;Numeric&quot;, &quot;numarray&quot;,</span>
<span class="sd">           or &quot;numpy&quot;</span>
<span class="sd">           </span>
<span class="sd"> - NumPy_dtype:</span>
<span class="sd">           returns the type of the data in an array, i.e., &#39;d&#39;, &#39;i&#39;, etc.</span>
<span class="sd">           </span>
<span class="sd"> - fortran_storage:</span>
<span class="sd">           transparent transform of an array to column major (Fortran) storage</span>
<span class="sd">           that preserves the nature (Numeric, numarray, numpy) of the array</span>

<span class="sd">Some frequently standard modules like sys, os, and operator are</span>
<span class="sd">imported into the namespace of the present module.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>

<span class="c"># The first task to accomplish in this module is to determine</span>
<span class="c"># whether to use Numeric, numarray, or numpy</span>

<span class="n">basic_NumPy</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># will later hold &#39;Numeric&#39;, &#39;numarray&#39;, or &#39;numpy&#39;</span>

<span class="c"># check the command line (this code is similar to matplotlib.numerix):</span>
<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s">&#39;argv&#39;</span><span class="p">):</span>  <span class="c"># Apache mod_python has no argv</span>
        <span class="k">for</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;--Numeric&quot;</span><span class="p">,</span> <span class="s">&quot;--numeric&quot;</span><span class="p">,</span> <span class="s">&quot;--NUMERIC&quot;</span><span class="p">]:</span>
                <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;Numeric&#39;</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;--Numarray&quot;</span><span class="p">,</span> <span class="s">&quot;--numarray&quot;</span><span class="p">,</span> <span class="s">&quot;--NUMARRAY&quot;</span><span class="p">]:</span>
                <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numarray&#39;</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;--NumPy&quot;</span><span class="p">,</span> <span class="s">&quot;--numpy&quot;</span><span class="p">,</span> <span class="s">&quot;--NUMPY&quot;</span><span class="p">]:</span>
                <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numpy&#39;</span>
                <span class="k">break</span>
        <span class="k">del</span> <span class="n">_a</span>  <span class="c"># don&#39;t pollute the global namespace</span>

<span class="c"># check if the user has already done an import Numeric, import numarray,</span>
<span class="c"># or import numpy; use the module that was imported</span>

<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;numpy&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numpy&#39;</span>
    <span class="k">elif</span> <span class="s">&#39;numarray&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numarray&#39;</span>
    <span class="k">elif</span> <span class="s">&#39;Numeric&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;Numeric&#39;</span>

<span class="c"># check the environment variable NUMPYARRAY:</span>
<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;NUMPYARRAY&#39;</span><span class="p">):</span>
        <span class="k">if</span>   <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;NUMPYARRAY&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numpy&#39;</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;NUMPYARRAY&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;numarray&#39;</span><span class="p">:</span>
            <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numarray&#39;</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;NUMPYARRAY&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Numeric&#39;</span><span class="p">:</span>
            <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;Numeric&#39;</span>

<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="n">basic_NumPy</span> <span class="o">=</span> <span class="s">&#39;numpy&#39;</span> <span class="c"># final default choice</span>

<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;Numeric&#39;</span><span class="p">,</span> <span class="s">&#39;numarray&#39;</span><span class="p">,</span> <span class="s">&#39;numpy&#39;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;cannot decide which Numerical Python &#39;</span>\
          <span class="s">&#39;implementation to use (ended up with &quot;</span><span class="si">%s</span><span class="s">&quot;)&#39;</span> <span class="o">%</span> <span class="n">basic_NumPy</span><span class="p">)</span>

<span class="c">#print &#39;from&#39;, basic_NumPy, &#39;import *&#39;</span>

<span class="c"># table of equivalent names of Numerical Python modules:</span>
<span class="c"># (used to import modules under Numeric, numarray, or numpy name)</span>

<span class="n">_NumPy_modules</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="s">&#39;Numeric&#39;</span><span class="p">,</span> <span class="s">&#39;numarray&#39;</span><span class="p">,</span> <span class="s">&#39;numpy&#39;</span><span class="p">),</span>
    <span class="c"># umath and Precision are included as part of Numeric, numarray, numpy</span>
    <span class="p">(</span><span class="s">&#39;LinearAlgebra&#39;</span><span class="p">,</span> <span class="s">&#39;numarray.linear_algebra.LinearAlgebra2&#39;</span><span class="p">,</span>
     <span class="s">&#39;numpy.linalg&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;RandomArray&#39;</span><span class="p">,</span> <span class="s">&#39;numarray.random_array.RandomArray2&#39;</span><span class="p">,</span> <span class="s">&#39;numpy.random&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;RNG&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;numpy.random&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;FFT&#39;</span><span class="p">,</span> <span class="s">&#39;numarray.fft&#39;</span><span class="p">,</span> <span class="s">&#39;numpy.fft&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;MLab&#39;</span><span class="p">,</span> <span class="s">&#39;numarray.linear_algebra.mlab&#39;</span><span class="p">,</span> <span class="s">&#39;numpy.oldnumeric.mlab&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;MA&#39;</span><span class="p">,</span> <span class="s">&#39;numarray.ma.MA&#39;</span><span class="p">,</span> <span class="s">&#39;numpy.ma&#39;</span><span class="p">),</span>
    <span class="p">)</span>
     
<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="o">==</span> <span class="s">&#39;numpy&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># fix backward compatibility with Numeric names:</span>
	<span class="kn">import</span> <span class="nn">numpy</span>
	<span class="n">oldversion</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;0&#39;</span><span class="p">)</span>
        <span class="n">majorversion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">minorversion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
	<span class="k">for</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_dummy1</span><span class="p">,</span> <span class="n">_numpy_name</span> <span class="ow">in</span> <span class="n">_NumPy_modules</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
	    <span class="k">if</span> <span class="n">oldversion</span> <span class="ow">and</span> <span class="p">(</span><span class="n">_Numeric_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RNG&#39;</span><span class="p">,</span> <span class="s">&#39;FFT&#39;</span><span class="p">]):</span>
		<span class="n">n</span><span class="p">,</span> <span class="n">module</span> <span class="o">=</span> <span class="n">_numpy_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
		<span class="k">exec</span> <span class="s">&quot;from </span><span class="si">%s</span><span class="s"> import </span><span class="si">%s</span><span class="s"> as </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">_Numeric_name</span><span class="p">)</span>
	    <span class="k">elif</span> <span class="n">oldversion</span> <span class="ow">and</span> <span class="p">(</span><span class="n">_Numeric_name</span> <span class="o">==</span> <span class="s">&#39;MLab&#39;</span><span class="p">):</span>
		<span class="kn">from</span> <span class="nn">numpy.lib</span> <span class="kn">import</span> <span class="n">mlab</span> <span class="k">as</span> <span class="n">MLab</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">oldversion</span> <span class="ow">or</span> <span class="p">(</span><span class="n">majorversion</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">minorversion</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span> \
                     <span class="ow">and</span> <span class="p">(</span><span class="n">_Numeric_name</span> <span class="o">==</span> <span class="s">&#39;MA&#39;</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">numpy.core.ma</span><span class="p">;</span> <span class="n">MA</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">ma</span>
	    <span class="k">elif</span> <span class="n">_numpy_name</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
		<span class="k">exec</span> <span class="s">&#39;import </span><span class="si">%s</span><span class="s">; </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
		<span class="p">(</span><span class="n">_numpy_name</span><span class="p">,</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_numpy_name</span><span class="p">)</span>
		
	<span class="k">del</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_dummy1</span><span class="p">,</span> <span class="n">_numpy_name</span><span class="p">,</span> <span class="n">_NumPy_modules</span>

	<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">oldversion</span><span class="p">:</span>
	    <span class="c"># get the old names too (NewAxis, Float, etc.):</span>
	    <span class="kn">from</span> <span class="nn">numpy.oldnumeric</span> <span class="kn">import</span> <span class="o">*</span>
	<span class="k">del</span> <span class="n">oldversion</span>
        <span class="c"># define new names compatible with Numeric:</span>
        <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">solve_linear_equations</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span>
        <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span>
        <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">determinant</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">det</span>
        <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span>
        <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span>

    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s">numpy import failed!</span><span class="se">\n</span><span class="s">&#39;</span>\
              <span class="s">&#39;see doc of </span><span class="si">%s</span><span class="s"> module for how to choose Numeric instead&#39;</span> <span class="o">%</span> \
              <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">__name__</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">array_output_precision</span><span class="p">(</span><span class="n">no_of_decimals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set no of decimals in printout of arrays.&quot;&quot;&quot;</span>
        <span class="n">arrayprint</span><span class="o">.</span><span class="n">set_precision</span><span class="p">(</span><span class="n">no_of_decimals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">arrmax</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the maximum of all the entries in a.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># not a NumPy array</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># does not work for nested sequences</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">isNumberType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arrmax of </span><span class="si">%s</span><span class="s"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">arrmin</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the minimum of all the entries in a.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># not a NumPy array</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># does not work for nested sequences</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">isNumberType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arrmin of </span><span class="si">%s</span><span class="s"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="n">NumPyArray</span> <span class="o">=</span> <span class="n">ndarray</span>

<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="o">==</span> <span class="s">&#39;numarray&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_numarray_name</span><span class="p">,</span> <span class="n">_dummy1</span> <span class="ow">in</span> <span class="n">_NumPy_modules</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">_numarray_name</span><span class="p">:</span>
                <span class="k">exec</span> <span class="s">&#39;import </span><span class="si">%s</span><span class="s">; </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                     <span class="p">(</span><span class="n">_numarray_name</span><span class="p">,</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_numarray_name</span><span class="p">)</span>

        <span class="c"># RNG is not supported, make an object that gives an error message:</span>
        <span class="k">class</span> <span class="nc">__Dummy</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;You have chosen the numarray package, &#39;</span>\
                <span class="s">&#39;but it does not have the functionality of the RNG module&#39;</span><span class="p">)</span>
        <span class="n">RNG</span> <span class="o">=</span> <span class="n">__Dummy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_numarray_name</span><span class="p">,</span> <span class="n">_dummy1</span><span class="p">,</span> <span class="n">__Dummy</span><span class="p">,</span> <span class="n">_NumPy_modules</span>
        
        <span class="kn">from</span> <span class="nn">numarray</span> <span class="kn">import</span> <span class="o">*</span>

    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s">numarray import failed!</span><span class="se">\n</span><span class="s">&#39;</span>\
        <span class="s">&#39;see doc of </span><span class="si">%s</span><span class="s"> module for how to choose Numeric instead&#39;</span> <span class="o">%</span> \
        <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">array_output_precision</span><span class="p">(</span><span class="n">no_of_decimals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set no of decimals in printout of arrays.&quot;&quot;&quot;</span>
        <span class="n">arrayprint</span><span class="o">.</span><span class="n">set_precision</span><span class="p">(</span><span class="n">no_of_decimals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">arrmax</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the maximum of all the entries in a.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># not a NumPy array</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># does not work for nested sequences</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">isNumberType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arrmax of </span><span class="si">%s</span><span class="s"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">arrmin</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the minimum of all the entries in a.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># not a NumPy array</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># does not work for nested sequences</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">isNumberType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arrmin of </span><span class="si">%s</span><span class="s"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="n">NumPyArray</span> <span class="o">=</span> <span class="n">NumArray</span>

<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="o">==</span> <span class="s">&#39;Numeric&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_dummy1</span><span class="p">,</span> <span class="n">_dummy2</span> <span class="ow">in</span> <span class="n">_NumPy_modules</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">_Numeric_name</span> <span class="o">!=</span> <span class="s">&#39;MA&#39;</span><span class="p">:</span>  <span class="c"># exclude MA, see comment above</span>
                <span class="k">exec</span> <span class="s">&#39;import </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">_Numeric_name</span>
        <span class="k">del</span> <span class="n">_Numeric_name</span><span class="p">,</span> <span class="n">_dummy1</span><span class="p">,</span> <span class="n">_dummy2</span><span class="p">,</span> <span class="n">_NumPy_modules</span>

        <span class="kn">from</span> <span class="nn">Numeric</span> <span class="kn">import</span> <span class="o">*</span>

        <span class="c"># the following is perhaps not a good idea;</span>
        <span class="c"># Numeric.UserArray and numarray.NumArray have different</span>
        <span class="c"># data attributes!</span>
        <span class="kn">from</span> <span class="nn">UserArray</span> <span class="kn">import</span> <span class="n">UserArray</span> <span class="k">as</span> <span class="n">NumArray</span>

        <span class="c"># define new numpy names:</span>
        <span class="n">newaxis</span> <span class="o">=</span> <span class="n">NewAxis</span>
        <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="p">))</span>

        
        <span class="c"># hack if LinearAlgebra.eigenvalues hang (because of trouble</span>
        <span class="c"># with gcc and Numeric and -ffloat-store flag):</span>

        <span class="n">_problems</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">_problems</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">numpy_eigenvalues</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Temporary wrapper for Numeric&#39;s LinearAlgebra.eigenvalues.</span>
<span class="sd">                Convert A to numpy, call numpy&#39;s eigenvalues,</span>
<span class="sd">                convert back to Numeric.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">import</span> <span class="nn">numpy</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">Numeric</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">Numeric</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">E</span>

            <span class="k">def</span> <span class="nf">numpy_eigenvectors</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Temporary wrapper for Numeric&#39;s LinearAlgebra.eigenvectors.</span>
<span class="sd">                Convert A to numpy, call numpy&#39;s eigenvalues,</span>
<span class="sd">                convert back to Numeric.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">import</span> <span class="nn">numpy</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="n">E</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="kn">import</span> <span class="nn">Numeric</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">Numeric</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">Numeric</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">V</span>

            <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">numpy_eigenvalues</span>
            <span class="n">LinearAlgebra</span><span class="o">.</span><span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">numpy_eigenvectors</span>
        <span class="k">del</span> <span class="n">_problems</span>
        
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s">Numeric import failed!</span><span class="se">\n</span><span class="s">&#39;</span>\
        <span class="s">&#39;see doc of </span><span class="si">%s</span><span class="s"> module for how to choose numarray instead&#39;</span> <span class="o">%</span> \
        <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">__name__</span><span class="p">))</span>


    <span class="c"># fix of matrixmultiply bug in Numeric (according to Fernando Perez,</span>
    <span class="c"># SciPy-dev mailing list, Sep 28, 2004:</span>
    <span class="c"># http://www.scipy.net/pipermail/scipy-dev/2004-September/002267.html,</span>
    <span class="c"># matrixmultiply is dot if not dotblas is used, otherwise dot is</span>
    <span class="c"># imported from dotblas, and matrixmultiply becomes the unoptimized</span>
    <span class="c"># version (Perez timed the difference to be 0.55 vs 122.6 on his</span>
    <span class="c"># computer)):</span>
    <span class="n">matrixmultiply</span> <span class="o">=</span> <span class="n">dot</span>

<div class="viewcode-block" id="array_output_precision"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.array_output_precision">[docs]</a>    <span class="k">def</span> <span class="nf">array_output_precision</span><span class="p">(</span><span class="n">no_of_decimals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set no of decimals in printout of arrays.&quot;&quot;&quot;</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">float_output_precision</span> <span class="o">=</span> <span class="n">no_of_decimals</span>
</div>
<div class="viewcode-block" id="arrmax"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.arrmax">[docs]</a>    <span class="k">def</span> <span class="nf">arrmax</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the maximum of all the entries in a.&quot;&quot;&quot;</span>
        <span class="c"># could set arrmax = amax in scipy if scipy is installed</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>  <span class="c"># use Python&#39;s list min</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># not a NumPy array</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">isNumberType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arrmax of </span><span class="si">%s</span><span class="s"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="arrmin"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.arrmin">[docs]</a>    <span class="k">def</span> <span class="nf">arrmin</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the minimum of all the entries in a.&quot;&quot;&quot;</span>
        <span class="c"># could set arrmin = amin in scipy if scipy is installed</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># not a NumPy array</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">isNumberType</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arrmin of </span><span class="si">%s</span><span class="s"> not supported&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</div>
    <span class="n">NumPyArray</span> <span class="o">=</span> <span class="n">ArrayType</span>

    <span class="c"># support numpy types:</span>
    <span class="n">int_</span> <span class="o">=</span> <span class="n">Int</span>
    <span class="n">int0</span> <span class="o">=</span> <span class="n">Int0</span>
    <span class="n">int8</span> <span class="o">=</span> <span class="n">Int8</span>
    <span class="n">int16</span> <span class="o">=</span> <span class="n">Int16</span>
    <span class="n">int32</span> <span class="o">=</span> <span class="n">Int32</span>
    <span class="n">float_</span> <span class="o">=</span> <span class="n">Float</span>
    <span class="n">float32</span> <span class="o">=</span> <span class="n">Float32</span>
    <span class="n">float64</span> <span class="o">=</span> <span class="n">Float64</span>
    <span class="n">complex_</span> <span class="o">=</span> <span class="n">Complex</span>
    <span class="n">complex64</span> <span class="o">=</span> <span class="n">Complex64</span>


<span class="n">_N</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">basic_NumPy</span><span class="p">)</span>
<span class="n">NumPy_version</span> <span class="o">=</span> <span class="n">_N</span><span class="o">.</span><span class="n">__version__</span>
<span class="k">del</span> <span class="n">_N</span>

<span class="c"># Short forms:</span>
<span class="n">fft</span> <span class="o">=</span> <span class="n">FFT</span>
<span class="n">mlab</span> <span class="o">=</span> <span class="n">MLab</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">MA</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="c"># for Numeric we do not import MA since it affects output format</span>
    <span class="k">pass</span>
<span class="n">ra</span> <span class="o">=</span> <span class="n">RandomArray</span>
<span class="n">la</span> <span class="o">=</span> <span class="n">LinearAlgebra</span> 

<div class="viewcode-block" id="NumPy_type"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.NumPy_type">[docs]</a><span class="k">def</span> <span class="nf">NumPy_type</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    @param a: NumPy array</span>
<span class="sd">    @return:  &quot;Numeric&quot;, &quot;numarray&quot;, or &quot;numpy&quot;, depending on which</span>
<span class="sd">    module that was used to generate the a array</span>

<span class="sd">    If type is list or tuple then the corresponding typename will be returned</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># check basic_NumPy type first to avoid possible import errors</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Numeric&#39;</span><span class="p">:</span> <span class="s">&#39;Numeric.ArrayType&#39;</span><span class="p">,</span>
             <span class="s">&#39;numarray&#39;</span><span class="p">:</span> <span class="s">&#39;numarray.NumArray&#39;</span><span class="p">,</span>
             <span class="s">&#39;numpy&#39;</span><span class="p">:</span> <span class="s">&#39;numpy.ndarray&#39;</span><span class="p">}</span>
	     
    <span class="c"># Check for non NumPy types first</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
	<span class="k">return</span> <span class="s">&quot;tuple&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
	<span class="k">return</span> <span class="s">&quot;list&quot;</span>
    <span class="k">exec</span> <span class="s">&quot;import </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">basic_NumPy</span> <span class="c"># Why isn&#39;t basic_NumPy imported?</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">basic_NumPy</span><span class="p">])):</span>
        <span class="k">return</span> <span class="n">basic_NumPy</span>

    <span class="c"># not the main NumPy type, try the others:</span>
    <span class="kn">import</span> <span class="nn">numpy</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;numpy&#39;</span>
    <span class="kn">import</span> <span class="nn">Numeric</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Numeric</span><span class="o">.</span><span class="n">ArrayType</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;Numeric&#39;</span>
    <span class="kn">import</span> <span class="nn">numarray</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">numarray</span><span class="o">.</span><span class="n">NumArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;numarray&#39;</span>
</div>
<div class="viewcode-block" id="NumPy_dtype"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.NumPy_dtype">[docs]</a><span class="k">def</span> <span class="nf">NumPy_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    @param a: NumPy array</span>
<span class="sd">    @return:  array data type, as a character,</span>
<span class="sd">    depending on which module that was</span>
<span class="sd">    used to generate the a array (a.typecode() for Numeric and</span>
<span class="sd">    numarray, a.dtype for numpy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">NumPy_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;Numeric&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">typecode</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">NumPy_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;numarray&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">typecode</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">NumPy_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;numpy&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;array should be NumPy array, not </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="fortran_storage"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.fortran_storage">[docs]</a><span class="k">def</span> <span class="nf">fortran_storage</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transparent transform of a NumPy array to Fortran (column major)</span>
<span class="sd">    storage.</span>

<span class="sd">    @param a:  NumPy array (generated in Python or C with C storage)</span>
<span class="sd">    @return: a new NumPy array with column major storage.</span>

<span class="sd">    Method: If a is of numpy type, numpy.asarray(a, fortran=True)</span>
<span class="sd">    is used to produce the new array.</span>
<span class="sd">    If a is of Numeric or numarray type, we want to preserve the array type</span>
<span class="sd">    and use a simple (and slower) transpose(transpose(a).copy()) instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">NumPy_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;Numeric&#39;</span> <span class="ow">or</span> <span class="n">NumPy_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;numarray&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">numpy</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fortran</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    </div>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Functionality of this module that extends Numerical Python</span>
<span class="sd">==========================================================</span>

<span class="sd"> - solve_tridiag_linear_system:</span>
<span class="sd">           returns the solution of a tridiagonal linear system</span>
<span class="sd"> - wrap2callable:</span>
<span class="sd">           tool for turning constants, discrete data, string</span>
<span class="sd">           formulas, function objects, or plain functions</span>
<span class="sd">           into an object that behaves as a function</span>
<span class="sd"> - NumPy_array_iterator:</span>
<span class="sd">           allows iterating over all array elements using</span>
<span class="sd">           a single, standard for loop (for value, index in iterator),</span>
<span class="sd">           has some additional features compared with numpy.ndenumerate</span>
<span class="sd"> - asarray_cpwarn:</span>
<span class="sd">           as ``numpy.asarray(a)``, but a warning or exception is issued if</span>
<span class="sd">           the array a is copied</span>
<span class="sd"> - meshgrid:</span>
<span class="sd">           extended version of ``numpy.meshgrid`` to 1D, 2D and 3D grids,</span>
<span class="sd">           with sparse or dense coordinate arrays and matrix or grid</span>
<span class="sd">           indexing</span>
<span class="sd"> - ndgrid:</span>
<span class="sd">           same as calling ``meshgrid`` with indexing=&#39;ij&#39; (matrix indexing)</span>
<span class="sd"> - float_eq:</span>
<span class="sd">           ``operator ==`` for float operands with tolerance,</span>
<span class="sd">           ``float_eq(a,b,tol)`` means ``abs(a-b) &lt; tol``</span>
<span class="sd">           works for both scalar and array arguments</span>
<span class="sd">           (similar functions for other operations exists:</span>
<span class="sd">           ``float_le``, ``float_lt``, ``float_ge``, ``float_gt``,</span>
<span class="sd">           ``float_ne``)</span>
<span class="sd"> - cut_noise:</span>
<span class="sd">           set all small (noise) elements of an array to zero</span>
<span class="sd"> - matrix_rank:</span>
<span class="sd">           compute the rank of a matrix</span>
<span class="sd"> - orth:</span>
<span class="sd">           compute an orthonormal basis from a matrix (taken from</span>
<span class="sd">           ``scipy.linalg`` to avoid ``scipy`` dependence)</span>
<span class="sd"> - null:</span>
<span class="sd">           compute the null space of a matrix</span>
<span class="sd"> - norm_L2, norm_l2, norm_L1, norm_l1, norm_inf:</span>
<span class="sd">           discrete and continuous norms for multi-dimensional arrays</span>
<span class="sd">           viewed as vectors</span>
<span class="sd"> - compute_historgram:</span>
<span class="sd">           return x and y arrays of a histogram, given a vector of samples</span>
<span class="sd"> - seq:</span>
<span class="sd">           ``seq(a,b,s, [type])`` computes numbers from ``a`` up to and</span>
<span class="sd">           including ``b`` in steps of s and (default) type ``float_``;</span>
<span class="sd"> - iseq:</span>
<span class="sd">           as ``seq``, but integer counters are computed</span>
<span class="sd">           (``iseq`` is an alternative to range where the</span>
<span class="sd">           upper limit is included in the sequence - this can</span>
<span class="sd">           be important for direct mapping of indices between</span>
<span class="sd">           mathematics and Python code);</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;numpyutils&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c">#else if name is some other module name:</span>
<span class="c"># this file is included in numpytools.py (through a preprocessing step)</span>
<span class="c"># and the code below then relies on previously imported Numerical Python</span>
<span class="c"># modules (Numeric, numpy, numarray)</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">FloatComparison</span> <span class="kn">import</span> <span class="n">float_eq</span><span class="p">,</span> <span class="n">float_ne</span><span class="p">,</span> <span class="n">float_lt</span><span class="p">,</span> <span class="n">float_le</span><span class="p">,</span> \
     <span class="n">float_gt</span><span class="p">,</span> <span class="n">float_ge</span>

<div class="viewcode-block" id="meshgrid"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.meshgrid">[docs]</a><span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s">&#39;xy&#39;</span><span class="p">,</span>
             <span class="n">memoryorder</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extension of ``numpy.meshgrid`` to 1D, 2D and 3D problems, and also</span>
<span class="sd">    support of both &quot;matrix&quot; and &quot;grid&quot; numbering.</span>

<span class="sd">    This extended version makes 1D/2D/3D coordinate arrays for</span>
<span class="sd">    vectorized evaluations of 1D/2D/3D scalar/vector fields over</span>
<span class="sd">    1D/2D/3D grids, given one-dimensional coordinate arrays x, y,</span>
<span class="sd">    and/or, z.</span>

<span class="sd">    &gt;&gt;&gt; x=linspace(0,1,3)        # coordinates along x axis</span>
<span class="sd">    &gt;&gt;&gt; y=linspace(0,1,2)        # coordinates along y axis</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = meshgrid(x,y)   # extend x and y for a 2D xy grid</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[ 0. ,  0.5,  1. ],</span>
<span class="sd">           [ 0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = meshgrid(x,y, sparse=True)  # make sparse output arrays</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[ 0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]])</span>

<span class="sd">    &gt;&gt;&gt; # 2D slice of a 3D grid, with z=const:</span>
<span class="sd">    &gt;&gt;&gt; z=5</span>
<span class="sd">    &gt;&gt;&gt; xv, yv, zc = meshgrid(x,y,z)</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[ 0. ,  0.5,  1. ],</span>
<span class="sd">           [ 0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; zc</span>
<span class="sd">    5</span>

<span class="sd">    &gt;&gt;&gt; # 2D slice of a 3D grid, with x=const:</span>
<span class="sd">    &gt;&gt;&gt; meshgrid(2,y,x)</span>
<span class="sd">    (2, array([[ 0.,  1.],</span>
<span class="sd">           [ 0.,  1.],</span>
<span class="sd">           [ 0.,  1.]]), array([[ 0. ,  0. ],</span>
<span class="sd">           [ 0.5,  0.5],</span>
<span class="sd">           [ 1. ,  1. ]]))</span>
<span class="sd">    &gt;&gt;&gt; meshgrid(0,1,5, sparse=True)  # just a 3D point</span>
<span class="sd">    (0, 1, 5)</span>
<span class="sd">    &gt;&gt;&gt; meshgrid(y)      # 1D grid; y is just returned</span>
<span class="sd">    array([ 0.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; meshgrid(x,y, indexing=&#39;ij&#39;)  # change to matrix indexing</span>
<span class="sd">    (array([[ 0. ,  0. ],</span>
<span class="sd">           [ 0.5,  0.5],</span>
<span class="sd">           [ 1. ,  1. ]]), array([[ 0.,  1.],</span>
<span class="sd">           [ 0.,  1.],</span>
<span class="sd">           [ 0.,  1.]]))</span>

<span class="sd">    Why does SciTools has its own meshgrid function when numpy has</span>
<span class="sd">    three similar functions, ``mgrid``, ``ogrid``, and ``meshgrid``?</span>
<span class="sd">    The ``meshgrid`` function in numpy is limited to two dimensions</span>
<span class="sd">    only, while the SciTools version can also work with 3D and 1D</span>
<span class="sd">    grids. In addition, the numpy version of ``meshgrid`` has no</span>
<span class="sd">    option for generating sparse grids to conserve memory, like we</span>
<span class="sd">    have in SciTools by specifying the ``sparse`` argument.</span>

<span class="sd">    Moreover, the numpy functions ``mgrid`` and ``ogrid`` does provide</span>
<span class="sd">    support for, respectively, full and sparse n-dimensional</span>
<span class="sd">    meshgrids, however, these functions uses slices to generate the</span>
<span class="sd">    meshgrids rather than one-dimensional coordinate arrays such as in</span>
<span class="sd">    Matlab. With slices, the user does not have the option to generate</span>
<span class="sd">    meshgrid with, e.g., irregular spacings, like::</span>

<span class="sd">    &gt;&gt;&gt; x = array([-1,-0.5,1,4,5], float)</span>
<span class="sd">    &gt;&gt;&gt; y = array([0,-2,-5], float)</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = meshgrid(x, y, sparse=False)</span>

<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[-1. , -0.5,  1. ,  4. ,  5. ],</span>
<span class="sd">           [-1. , -0.5,  1. ,  4. ,  5. ],</span>
<span class="sd">           [-1. , -0.5,  1. ,  4. ,  5. ]])</span>

<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [-2., -2., -2., -2., -2.],</span>
<span class="sd">           [-5., -5., -5., -5., -5.]])</span>


<span class="sd">    In addition to the reasons mentioned above, the ``meshgrid``</span>
<span class="sd">    function in numpy supports only Cartesian indexing, i.e., x and y,</span>
<span class="sd">    not matrix indexing, i.e., rows and columns (on the other hand,</span>
<span class="sd">    ``mgrid`` and ``ogrid`` supports only matrix indexing). The</span>
<span class="sd">    ``meshgrid`` function in SciTools supports both indexing</span>
<span class="sd">    conventions through the ``indexing`` keyword argument. Giving the</span>
<span class="sd">    string ``&#39;ij&#39;`` returns a meshgrid with matrix indexing, while</span>
<span class="sd">    ``&#39;xy&#39;`` returns a meshgrid with Cartesian indexing. The</span>
<span class="sd">    difference is illustrated by the following code snippet::</span>

<span class="sd">      nx = 10</span>
<span class="sd">      ny = 15</span>

<span class="sd">      x = linspace(-2,2,nx)</span>
<span class="sd">      y = linspace(-2,2,ny)</span>

<span class="sd">      xv, yv = meshgrid(x, y, sparse=False, indexing=&#39;ij&#39;)</span>
<span class="sd">      for i in range(nx):</span>
<span class="sd">          for j in range(ny):</span>
<span class="sd">              # treat xv[i,j], yv[i,j]</span>

<span class="sd">      xv, yv = meshgrid(x, y, sparse=False, indexing=&#39;xy&#39;)</span>
<span class="sd">      for i in range(nx):</span>
<span class="sd">          for j in range(ny):</span>
<span class="sd">              # treat xv[j,i], yv[j,i]</span>

<span class="sd">    It is not entirely true that matrix indexing is not supported by the</span>
<span class="sd">    ``meshgrid`` function in numpy because we can just switch the order of</span>
<span class="sd">    the first two input and output arguments::</span>

<span class="sd">    &gt;&gt;&gt; yv, xv = numpy.meshgrid(y, x)</span>
<span class="sd">    &gt;&gt;&gt; # same as:</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = meshgrid(x, y, indexing=&#39;ij&#39;)</span>

<span class="sd">    However, we think it is clearer to have the logical &quot;x, y&quot;</span>
<span class="sd">    sequence on the left-hand side and instead adjust a keyword argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">types</span>
    <span class="k">def</span> <span class="nf">fixed</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">NoneType</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">arr1D</span><span class="p">(</span><span class="n">coor</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="c"># if two of the arguments are fixed, we have a 1D grid, and</span>
    <span class="c"># the third argument can be reused as is:</span>

    <span class="k">if</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fixed</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fixed</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">fixed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fixed</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">y</span>
    <span class="k">if</span> <span class="n">fixed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fixed</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">z</span>

    <span class="c"># if x,y,z are identical, make copies:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">x</span><span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="n">x</span><span class="p">:</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="n">y</span><span class="p">:</span> <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c"># x, y, or z not numpy array</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">memoryorder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Keyword argument &#39;memoryorder&#39; is deprecated and will be &quot;</span> \
              <span class="s">&quot;removed in the future. Please use the &#39;indexing&#39; keyword &quot;</span> \
              <span class="s">&quot;argument instead.&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">memoryorder</span> <span class="o">==</span> <span class="s">&#39;xyz&#39;</span><span class="p">:</span>
            <span class="n">indexing</span> <span class="o">=</span> <span class="s">&#39;ij&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexing</span> <span class="o">=</span> <span class="s">&#39;xy&#39;</span>

    <span class="c"># If the keyword argument sparse is set to False, the full N-D matrix</span>
    <span class="c"># (not only the 1-D vector) should be returned. The mult_fact variable</span>
    <span class="c"># should then be updated as necessary.</span>
    <span class="n">mult_fact</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c"># if only one argument is fixed, we have a 2D grid:</span>
    <span class="k">if</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fixed</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s">&#39;ij&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span>

    <span class="k">if</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fixed</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s">&#39;ij&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span>

    <span class="k">if</span> <span class="n">fixed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s">&#39;ij&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> <span class="n">z</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span>

    <span class="c"># or maybe we have a full 3D grid:</span>
    <span class="k">if</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr1D</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s">&#39;ij&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> \
                   <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> \
                   <span class="n">z</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> \
                   <span class="n">y</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">mult_fact</span><span class="p">,</span> \
                   <span class="n">z</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">mult_fact</span>

    <span class="c"># at this stage we assume that we just have scalars:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ndgrid"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.ndgrid">[docs]</a><span class="k">def</span> <span class="nf">ndgrid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Same as calling ``meshgrid`` with *indexing* = ``&#39;ij&#39;`` (see</span>
<span class="sd">    ``meshgrid`` for documentation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;indexing&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ij&#39;</span>
    <span class="k">return</span> <span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="length"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.length">[docs]</a><span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the length of the largest dimension of array a.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="cut_noise"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.cut_noise">[docs]</a><span class="k">def</span> <span class="nf">cut_noise</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set elements in array a to zero if the absolute value is</span>
<span class="sd">    less than tol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">a</span>

</div>
<div class="viewcode-block" id="Gram_Schmidt1"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.Gram_Schmidt1">[docs]</a><span class="k">def</span> <span class="nf">Gram_Schmidt1</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">row_wise_storage</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the Gram-Schmidt orthogonalization algorithm to a set</span>
<span class="sd">    of vectors. vecs is a two-dimensional array where the vectors</span>
<span class="sd">    are stored row-wise, or vecs may be a list of vectors, where</span>
<span class="sd">    each vector can be a list or a one-dimensional array.</span>
<span class="sd">    An array basis is returned, where basis[i,:] (row_wise_storage</span>
<span class="sd">    is True) or basis[:,i] (row_wise_storage is False) is the i-th</span>
<span class="sd">    orthonormal vector in the basis.</span>

<span class="sd">    This function does not handle null vectors, see Gram_Schmidt</span>
<span class="sd">    for a (slower) function that does.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

    <span class="n">vecs</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>  <span class="c"># transform to array if list of vectors</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vecs</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">vecs</span><span class="p">))</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">basis</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">basis</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">basis</span><span class="p">[:,</span><span class="n">i</span><span class="p">]))</span>
    	<span class="n">U</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[:,:</span><span class="n">i</span><span class="p">]</span>
	<span class="n">P</span> <span class="o">=</span> <span class="n">eye</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">U</span><span class="p">)),</span> <span class="n">transpose</span><span class="p">(</span><span class="n">U</span><span class="p">)))</span>
	<span class="n">basis</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
	<span class="n">basis</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">basis</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">basis</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="k">if</span> <span class="n">row_wise_storage</span> <span class="k">else</span> <span class="n">basis</span>

</div>
<div class="viewcode-block" id="Gram_Schmidt"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.Gram_Schmidt">[docs]</a><span class="k">def</span> <span class="nf">Gram_Schmidt</span><span class="p">(</span><span class="n">vecs</span><span class="p">,</span> <span class="n">row_wise_storage</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-10</span><span class="p">,</span>
                 <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">remove_null_vectors</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">remove_noise</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the Gram-Schmidt orthogonalization algorithm to a set</span>
<span class="sd">    of vectors. vecs is a two-dimensional array where the vectors</span>
<span class="sd">    are stored row-wise, or vecs may be a list of vectors, where</span>
<span class="sd">    each vector can be a list or a one-dimensional array.</span>

<span class="sd">    The argument tol is a tolerance for null vectors (the absolute</span>
<span class="sd">    value of all elements must be less than tol to have a null</span>
<span class="sd">    vector).</span>

<span class="sd">    If normalize is True, the orthogonal vectors are normalized to form</span>
<span class="sd">    an orthonormal basis.</span>

<span class="sd">    If remove_null_vectors is True, all null vectors are removed from</span>
<span class="sd">    the resulting basis.</span>

<span class="sd">    If remove_noise is True, all elements whose absolute values are</span>
<span class="sd">    less than tol are set to zero.</span>

<span class="sd">    An array basis is returned, where basis[i,:] (row_wise_storage</span>
<span class="sd">    is True) or basis[:,i] (row_wise_storage is False) is the i-th</span>
<span class="sd">    orthogonal vector in the basis.</span>

<span class="sd">    This function handles null vectors, see Gram_Schmidt1</span>
<span class="sd">    for a (faster) function that does not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># The algorithm below views vecs as a matrix A with the vectors</span>
    <span class="c"># stored as columns:</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>  <span class="c"># transform to array if list of vectors</span>
    <span class="k">if</span> <span class="n">row_wise_storage</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">vecs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">v</span> <span class="o">-=</span> <span class="p">(</span><span class="n">vdot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="n">vi</span><span class="p">)</span><span class="o">/</span><span class="n">vdot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span><span class="n">vi</span><span class="p">))</span><span class="o">*</span><span class="n">vi</span>
        <span class="n">V</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">if</span> <span class="n">remove_null_vectors</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">ix_</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">indices</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">V</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="n">j</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">remove_noise</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">cut_noise</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="k">if</span> <span class="n">row_wise_storage</span> <span class="k">else</span> <span class="n">V</span>

</div>
<div class="viewcode-block" id="matrix_rank"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">matrix_rank</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the rank of a matrix A (rank means an estimate of</span>
<span class="sd">    the number of linearly independent rows or columns).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">maxabs</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">maxdim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">maxabs</span><span class="o">*</span><span class="n">maxdim</span><span class="o">*</span><span class="mf">1E-13</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="orth"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.orth">[docs]</a><span class="k">def</span> <span class="nf">orth</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (Plain copy from scipy.linalg.orth - this one here applies numpy.svd</span>
<span class="sd">    and avoids the need for having scipy installed.)</span>

<span class="sd">    Construct an orthonormal basis for the range of A using SVD.</span>

<span class="sd">    @param A: array, shape (M, N)</span>
<span class="sd">    @return:</span>
<span class="sd">        Q : array, shape (M, K)</span>
<span class="sd">        Orthonormal basis for the range of A.</span>
<span class="sd">        K = effective rank of A, as determined by automatic cutoff</span>

<span class="sd">    see also svd (singular value decomposition of a matrix in scipy.linalg)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vh</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">eps</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,:</span><span class="n">num</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Q</span>

</div>
<div class="viewcode-block" id="null"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.null">[docs]</a><span class="k">def</span> <span class="nf">null</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">row_wise_storage</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the null space of a matrix A.</span>
<span class="sd">    If row_wise_storage is True, a two-dimensional array where the</span>
<span class="sd">    vectors that span the null space are stored as rows, otherwise</span>
<span class="sd">    they are stored as columns.</span>

<span class="sd">    Code by Bastian Weber based on code by Robert Kern and Ryan Krauss.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">null</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">tol</span><span class="p">))</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">]</span>
    <span class="n">null_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">null_space</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">null_mask</span><span class="p">,</span> <span class="n">vh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">null_space</span> <span class="o">=</span> <span class="n">conjugate</span><span class="p">(</span><span class="n">null_space</span><span class="p">)</span>  <span class="c"># in case of complex values</span>
    <span class="k">if</span> <span class="n">row_wise_storage</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">null_space</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">null_space</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Heaviside"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.Heaviside">[docs]</a><span class="k">class</span> <span class="nc">Heaviside</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Standard and smoothed Heaviside function.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Heaviside.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.Heaviside.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>          <span class="c"># smoothing parameter</span>
</div>
<div class="viewcode-block" id="Heaviside.__call__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.Heaviside.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">)):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smooth_scalar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smooth_vec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_exact_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_exact_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span>  <span class="c"># works for scalars and arrays, but returns bool</span>

    <span class="k">def</span> <span class="nf">_exact_vec1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_exact_vec2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">_smooth_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">eps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_smooth_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">condition1</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">eps</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">condition1</span><span class="p">]</span>
        <span class="n">r</span><span class="p">[</span><span class="n">condition1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">xc</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">xc</span><span class="o">/</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span>

<div class="viewcode-block" id="Heaviside.plot"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.Heaviside.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return arrays x, y for plotting the Heaviside function</span>
<span class="sd">        H(x-`center`) on [`xmin`, `xmax`]. For the exact</span>
<span class="sd">        Heaviside function,</span>
<span class="sd">        ``x = [xmin, center, center, xmax]; y = [0, 0, 1, 1]``,</span>
<span class="sd">        while for the smoothed version, the ``x`` array</span>
<span class="sd">        is computed on basis of the `eps` parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mf">200.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                <span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">center</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span>
                <span class="n">linspace</span><span class="p">(</span><span class="n">center</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">center</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">linspace</span><span class="p">(</span><span class="n">center</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

</div></div>
<div class="viewcode-block" id="DiracDelta"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.DiracDelta">[docs]</a><span class="k">class</span> <span class="nc">DiracDelta</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smoothed Dirac delta function:</span>
<span class="sd">    $\frac{1}{2\epsilon}(1 + \cos(\pi x/\epsilon)$ when</span>
<span class="sd">    $x\in [-\epsilon, \epsilon]$ and 0 elsewhere.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DiracDelta.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.DiracDelta.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;eps=0 is not allowed in class DiracDelta.&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DiracDelta.__call__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.DiracDelta.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_smooth</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_smooth_vec</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> x is wrong&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">eps</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_smooth_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">condition1</span> <span class="o">-</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">eps</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">condition1</span><span class="p">]</span>
        <span class="n">r</span><span class="p">[</span><span class="n">condition1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">xc</span><span class="o">/</span><span class="n">eps</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span>

<div class="viewcode-block" id="DiracDelta.plot"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.DiracDelta.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return arrays x, y for plotting the DiracDelta function</span>
<span class="sd">        centered in `center` on the interval [`xmin`, `xmax`].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mf">200.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">center</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span>
            <span class="n">linspace</span><span class="p">(</span><span class="n">center</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">center</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">linspace</span><span class="p">(</span><span class="n">center</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</div></div>
<div class="viewcode-block" id="IndicatorFunction"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.IndicatorFunction">[docs]</a><span class="k">class</span> <span class="nc">IndicatorFunction</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Indicator function $I(x; L, R)$, which is 1 in $[L, R]$, and 0</span>
<span class="sd">    outside. Two parameters ``eps_L`` and ``eps_R`` can be set</span>
<span class="sd">    to provide smoothing of the left and/or right discontinuity</span>
<span class="sd">    in the indicator function. The indicator function is</span>
<span class="sd">    defined in terms of the Heaviside function (using class</span>
<span class="sd">    :class:`Heaviside`): $I(x; R, L) = H(x-L)H(R-x)$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="IndicatorFunction.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.IndicatorFunction.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">eps_L</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eps_R</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `interval` is a 2-tuple/list defining the interval [L, R] where</span>
<span class="sd">        the indicator function is 1.</span>
<span class="sd">        `eps` is a smoothing parameter: ``eps=0`` gives the standard</span>
<span class="sd">        discontinuous indicator function, while a value different</span>
<span class="sd">        from 0 gives rapid change from 0 to 1 over an interval of</span>
<span class="sd">        length 2*`eps`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_R</span> <span class="o">=</span> <span class="n">eps_L</span><span class="p">,</span> <span class="n">eps_R</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Heaviside_L</span> <span class="o">=</span> <span class="n">Heaviside</span><span class="p">(</span><span class="n">eps_L</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Heaviside_R</span> <span class="o">=</span> <span class="n">Heaviside</span><span class="p">(</span><span class="n">eps_R</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IndicatorFunction.__call__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.IndicatorFunction.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_L</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Avoid using Heaviside functions since we want 1</span>
            <span class="c"># as value for x in [L,R) (important when indicator</span>
            <span class="c"># functions are added)</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-10</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="c">#return 0 if x &lt; self.L or x &gt;= self.R else 1</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">r</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c">#r[x &gt;= self.R] = 0</span>
                <span class="n">r</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Heaviside_L</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Heaviside_R</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IndicatorFunction.plot"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.IndicatorFunction.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return arrays x, y for plotting IndicatorFunction</span>
<span class="sd">        on [`xmin`, `xmax`]. For the exact discontinuous</span>
<span class="sd">        indicator function, we typically have</span>
<span class="sd">        ``x = [xmin, L, L, R, R, xmax]; y = [0, 0, 1, 1, 0, 0]``,</span>
<span class="sd">        while for the smoothed version, the densities of</span>
<span class="sd">        coordinates in the ``x`` array is computed on basis of the</span>
<span class="sd">        `eps` parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xmin</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="ow">or</span> <span class="n">xmax</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;xmin=</span><span class="si">%g</span><span class="s"> &gt; L=</span><span class="si">%g</span><span class="s"> or xmax=</span><span class="si">%g</span><span class="s"> &lt; R=</span><span class="si">%g</span><span class="s"> is meaningless for plot&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mf">200.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                <span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span>
                <span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</div>
<div class="viewcode-block" id="IndicatorFunction.__str__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.IndicatorFunction.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="s">&#39;eps=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
        <span class="k">return</span> <span class="s">&#39;I(x)=1 on [</span><span class="si">%g</span><span class="s">, </span><span class="si">%g</span><span class="s">] </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IndicatorFunction.__repr__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.IndicatorFunction.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;IndicatorFunction([</span><span class="si">%g</span><span class="s">, </span><span class="si">%g</span><span class="s">], eps=</span><span class="si">%g</span><span class="s">)&#39;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="PiecewiseConstant"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.PiecewiseConstant">[docs]</a><span class="k">class</span> <span class="nc">PiecewiseConstant</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a piecewise constant function.</span>
<span class="sd">    The discontinuities can be smoothed out.</span>
<span class="sd">    In this latter case the piecewise constant function is represented</span>
<span class="sd">    as a sum of indicator functions (:class:`IndicatorFunction`)</span>
<span class="sd">    times corresponding values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PiecewiseConstant.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.PiecewiseConstant.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;domain starts at </span><span class="si">%g</span><span class="s">, while data[0][0]=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> \
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_indicator_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Ensure eps_L=0 at the left and eps_R=0 at the right,</span>
        <span class="c"># while both are eps at internal boundaries,</span>
        <span class="c"># i.e., the function is always discontinuous at the start and end</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">eps_L</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">eps_R</span> <span class="o">=</span> <span class="n">eps</span>  <span class="c"># left boundary</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">eps_R</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">eps_L</span> <span class="o">=</span> <span class="n">eps</span>  <span class="c"># right boundary</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eps_L</span> <span class="o">=</span> <span class="n">eps_R</span> <span class="o">=</span> <span class="n">eps</span>     <span class="c"># internal boundary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indicator_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">IndicatorFunction</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span>
                 <span class="n">eps_L</span><span class="o">=</span><span class="n">eps_L</span><span class="p">,</span> <span class="n">eps_R</span><span class="o">=</span><span class="n">eps_R</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="PiecewiseConstant.__call__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.PiecewiseConstant.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">value</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> \
                       <span class="k">for</span> <span class="n">I</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> \
                       <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indicator_functions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="PiecewiseConstant.value"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.PiecewiseConstant.value">[docs]</a>    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alternative implementation to __call__.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">xi</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">a</span>
</div>
<div class="viewcode-block" id="PiecewiseConstant.plot"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.PiecewiseConstant.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">I</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indicator_functions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">):</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
                <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
                <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">200</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="mi">21</span><span class="p">)]</span>
                <span class="c"># Iterate over all internal discontinuities</span>
                <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indicator_functions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">L</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">L</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">R</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span>
                <span class="c"># Last part</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">R</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">I</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>


<span class="c"># the norm_* functions also work for arrays with dimensions larger than 2,</span>
<span class="c"># in contrast to (most of) the numpy.linalg.norm functions</span>
</div></div>
<div class="viewcode-block" id="norm_l2"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.norm_l2">[docs]</a><span class="k">def</span> <span class="nf">norm_l2</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standard l2 norm of a multi-dimensional array u viewed as a vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="norm_L2"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.norm_L2">[docs]</a><span class="k">def</span> <span class="nf">norm_L2</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    L2 norm of a multi-dimensional array u viewed as a vector</span>
<span class="sd">    (norm is norm_l2/n, where n is length of u (no of elements)).</span>

<span class="sd">    If u holds function values and the norm of u is supposed to</span>
<span class="sd">    approximate an integral (L2 norm) of the function, this (and</span>
<span class="sd">    not norm_l2) is the right norm function to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">norm_l2</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="norm_l1"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.norm_l1">[docs]</a><span class="k">def</span> <span class="nf">norm_l1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    l1 norm of a multi-dimensional array u viewed as a vector:</span>
<span class="sd">    ``linalg.norm(u.ravel(),1)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#return sum(abs(u.ravel()))</span>
    <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="norm_L1"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.norm_L1">[docs]</a><span class="k">def</span> <span class="nf">norm_L1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    L1 norm of a multi-dimensional array u viewed as a vector:</span>
<span class="sd">    ``norm_l1(u)/float(u.size)``.</span>

<span class="sd">    If *u* holds function values and the norm of u is supposed to</span>
<span class="sd">    approximate an integral (L1 norm) of the function, this (and</span>
<span class="sd">    not norm_l1) is the right norm function to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">norm_l1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="norm_inf"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.norm_inf">[docs]</a><span class="k">def</span> <span class="nf">norm_inf</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Infinity/max norm of a multi-dimensional array u viewed as a vector.&quot;&quot;&quot;</span>
    <span class="c">#return abs(u.ravel()).max()</span>
    <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">inf</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="solve_tridiag_linear_system"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.solve_tridiag_linear_system">[docs]</a><span class="k">def</span> <span class="nf">solve_tridiag_linear_system</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve an n times n tridiagonal linear system of the form::</span>

<span class="sd">     A[0,1]*x[0] + A[0,2]*x[1]                                        = 0</span>
<span class="sd">     A[1,0]*x[0] + A[1,1]*x[1] + A[1,2]*x[2]                          = 0</span>
<span class="sd">     ...</span>
<span class="sd">     ...</span>
<span class="sd">              A[k,0]*x[k-1] + A[k,1]*x[k] + A[k,2]*x[k+1]             = 0</span>
<span class="sd">     ...</span>
<span class="sd">                  A[n-2,0]*x[n-3] + A[n-2,1]*x[n-2] + A[n-2,2]*x[n-1] = 0</span>
<span class="sd">     ...</span>
<span class="sd">                                    A[n-1,0]*x[n-2] + A[n-1,1]*x[n-1] = 0</span>

<span class="sd">    The diagonal of the coefficent matrix is stored in A[:,1],</span>
<span class="sd">    the subdiagonal is stored in A[1:,0], and the superdiagonal</span>
<span class="sd">    is stored in A[:-1,2].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#The storage is not memory friendly in Python/C (diagonals stored</span>
    <span class="c">#columnwise in A), but if A is sent to F77 for high-performance</span>
    <span class="c">#computing, a copy is taken and the F77 routine works with the</span>
    <span class="c">#same algorithm and hence optimal (columnwise traversal)</span>
    <span class="c">#Fortran storage.</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">factorize_tridiag_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">solve_tridiag_factored_system</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="factorize_tridiag_matrix"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.factorize_tridiag_matrix">[docs]</a><span class="k">def</span> <span class="nf">factorize_tridiag_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the factorization step only in solving a tridiagonal</span>
<span class="sd">    linear system. See the function solve_tridiag_linear_system</span>
<span class="sd">    for how the matrix *A* is stored.</span>
<span class="sd">    Two arrays, *c* and *d*, are returned, and these represent,</span>
<span class="sd">    together with superdiagonal *A[:-1,2]*, the factorized form of</span>
<span class="sd">    *A*. To solve a system with ``solve_tridiag_factored_system``,</span>
<span class="sd">    *A*, *c*, and *d* must be passed as arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c"># scratch arrays:</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">);</span>  <span class="n">c</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">);</span>  <span class="n">m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>

    <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">iseq</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>

</div>
<div class="viewcode-block" id="solve_tridiag_factored_system"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.solve_tridiag_factored_system">[docs]</a><span class="k">def</span> <span class="nf">solve_tridiag_factored_system</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The backsubsitution part of solving a tridiagonal linear system.</span>
<span class="sd">    The right-hand side is b, while *A*, *c*, and *d* represent the</span>
<span class="sd">    factored matrix (see the factorize_tridiag_matrix function).</span>
<span class="sd">    The solution x to A*x=b is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>  <span class="c"># solution</span>

    <span class="c"># back substitution:</span>
    <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">iseq</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inc</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>


</div>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">Pmw</span>
    <span class="k">class</span> <span class="nc">NumPy2BltVector</span><span class="p">(</span><span class="n">Pmw</span><span class="o">.</span><span class="n">Blt</span><span class="o">.</span><span class="n">Vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy a numpy array to a BLT vector:</span>
<span class="sd">        # a: some numpy array</span>
<span class="sd">        b = NumPy2BltVector(a)  # b is BLT vector</span>
<span class="sd">        g = Pmw.Blt.Graph(someframe)</span>
<span class="sd">        # send b to g for plotting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
            <span class="n">Pmw</span><span class="o">.</span><span class="n">Blt</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>  <span class="c"># copy elements</span>
<span class="k">except</span><span class="p">:</span>
<div class="viewcode-block" id="NumPy2BltVector"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.NumPy2BltVector">[docs]</a>    <span class="k">class</span> <span class="nc">NumPy2BltVector</span><span class="p">:</span>
<div class="viewcode-block" id="NumPy2BltVector.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.NumPy2BltVector.__init__">[docs]</a>        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&quot;Python is not working properly with BLT&quot;</span><span class="p">)</span>
</div></div>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scitools.StringFunction</span> <span class="kn">import</span> <span class="n">StringFunction</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c"># wrap2callable may not work</span>


<span class="k">class</span> <span class="nc">WrapNo2Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Turn a number (constant) into a callable function.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant</span> <span class="o">=</span> <span class="n">constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array_shape</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; w = WrapNo2Callable(4.4)</span>
<span class="sd">        &gt;&gt;&gt; w(99)</span>
<span class="sd">        4.4000000000000004</span>
<span class="sd">        &gt;&gt;&gt; # try vectorized computations:</span>
<span class="sd">        &gt;&gt;&gt; x = linspace(1, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; y = linspace(1, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; xv = x[:,NewAxis]; yv = y[NewAxis,:]</span>
<span class="sd">        &gt;&gt;&gt; xv + yv</span>
<span class="sd">        array([[ 2.,  3.],</span>
<span class="sd">               [ 3.,  4.],</span>
<span class="sd">               [ 4.,  5.],</span>
<span class="sd">               [ 5.,  6.]])</span>
<span class="sd">        &gt;&gt;&gt; w(xv, yv)</span>
<span class="sd">        array([[ 4.4,  4.4],</span>
<span class="sd">               [ 4.4,  4.4],</span>
<span class="sd">               [ 4.4,  4.4],</span>
<span class="sd">               [ 4.4,  4.4]])</span>

<span class="sd">        If you want to call such a function object with space-time</span>
<span class="sd">        arguments and vectorized expressions, make sure the time</span>
<span class="sd">        argument is not the first argument. That is,</span>
<span class="sd">        w(xv, yv, t) is fine, but w(t, xv, yv) will return 4.4,</span>
<span class="sd">        not the desired array!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="c"># scalar version:</span>
            <span class="c"># (operator.isNumberType(args[0]) cannot be used as it is</span>
            <span class="c"># true also for numpy arrays</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># assume numpy array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_array_shape</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_shape</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
                <span class="c"># could store r (allocated once) and just return reference</span>
                <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">_set_array_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="c"># vectorized version:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># to get right dimension of the return array,</span>
        <span class="c"># compute with args in a simple formula (sum of args)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">a</span>  <span class="c"># in-place r+= won&#39;t work</span>
            <span class="c"># (handles x,y,t - the last t just adds a constant)</span>
            <span class="c"># an argument sequence t, x, y  will fail (1st arg</span>
            <span class="c"># is not a numpy array)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array_shape</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span>

    <span class="c"># The problem with this class is that, in the vectorized version,</span>
    <span class="c"># the array shape is determined in the first call, i.e., later</span>
    <span class="c"># calls may return an array with the wrong shape if the shape of</span>
    <span class="c"># the input arguments change! Sometimes, when called along boundaries</span>
    <span class="c"># of grids, the shape may change so the next implementation is</span>
    <span class="c"># slower and safer.</span>

<div class="viewcode-block" id="WrapNo2Callable"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.WrapNo2Callable">[docs]</a><span class="k">class</span> <span class="nc">WrapNo2Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Turn a number (constant) into a callable function.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="WrapNo2Callable.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.WrapNo2Callable.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant</span> <span class="o">=</span> <span class="n">constant</span>
</div>
<div class="viewcode-block" id="WrapNo2Callable.__call__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.WrapNo2Callable.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; w = WrapNo2Callable(4.4)</span>
<span class="sd">        &gt;&gt;&gt; w(99)</span>
<span class="sd">        4.4000000000000004</span>
<span class="sd">        &gt;&gt;&gt; # try vectorized computations:</span>
<span class="sd">        &gt;&gt;&gt; x = linspace(1, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; y = linspace(1, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; xv = x[:,NewAxis]; yv = y[NewAxis,:]</span>
<span class="sd">        &gt;&gt;&gt; xv + yv</span>
<span class="sd">        array([[ 2.,  3.],</span>
<span class="sd">               [ 3.,  4.],</span>
<span class="sd">               [ 4.,  5.],</span>
<span class="sd">               [ 5.,  6.]])</span>
<span class="sd">        &gt;&gt;&gt; w(xv, yv)</span>
<span class="sd">        array([[ 4.4,  4.4],</span>
<span class="sd">               [ 4.4,  4.4],</span>
<span class="sd">               [ 4.4,  4.4],</span>
<span class="sd">               [ 4.4,  4.4]])</span>

<span class="sd">        If you want to call such a function object with space-time</span>
<span class="sd">        arguments and vectorized expressions, make sure the time</span>
<span class="sd">        argument is not the first argument. That is,</span>
<span class="sd">        w(xv, yv, t) is fine, but w(t, xv, yv) will return 4.4,</span>
<span class="sd">        not the desired array!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="c"># scalar version:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># vectorized version:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c"># to get right dimension of the return array,</span>
            <span class="c"># compute with args in a simple formula (sum of args)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">a</span>  <span class="c"># in-place r+= won&#39;t work</span>
                <span class="c"># (handles x,y,t - the last t just adds a constant)</span>
            <span class="n">r</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
            <span class="k">return</span> <span class="n">r</span>

</div></div>
<div class="viewcode-block" id="WrapDiscreteData2Callable"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.WrapDiscreteData2Callable">[docs]</a><span class="k">class</span> <span class="nc">WrapDiscreteData2Callable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn discrete data on a uniform grid into a callable function,</span>
<span class="sd">    i.e., equip the data with an interpolation function.</span>

<span class="sd">    &gt;&gt;&gt; x = linspace(0, 1, 11)</span>
<span class="sd">    &gt;&gt;&gt; y = 1+2*x</span>
<span class="sd">    &gt;&gt;&gt; f = WrapDiscreteData2Callable((x,y))</span>
<span class="sd">    &gt;&gt;&gt; # or just use the wrap2callable generic function:</span>
<span class="sd">    &gt;&gt;&gt; f = wrap2callable((x,y))</span>
<span class="sd">    &gt;&gt;&gt; f(0.5)   # evaluate f(x) by interpolation</span>
<span class="sd">    1.5</span>
<span class="sd">    &gt;&gt;&gt; f(0.5, 0.1)  # discrete data with extra time prm: f(x,t)</span>
<span class="sd">    1.5</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WrapDiscreteData2Callable.__init__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.WrapDiscreteData2Callable.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>  <span class="c"># (x,y,f) data for an f(x,y) function</span>

        <span class="kn">from</span> <span class="nn">scitools.misc</span> <span class="kn">import</span> <span class="n">import_module</span>
        <span class="n">InterpolatingFunction</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span>
            <span class="s">&#39;Scientific.Functions.Interpolation&#39;</span><span class="p">,</span> <span class="s">&#39;InterpolatingFunction&#39;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">Scientific</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Scientific</span><span class="o">.</span><span class="n">__version__</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s">&#39;2.9.1&#39;</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s">&#39;ScientificPython is in (old) version </span><span class="si">%s</span><span class="s">, need </span><span class="si">%s</span><span class="s">&#39;</span> \
                <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interpolating_function</span> <span class="o">=</span> \
             <span class="n">InterpolatingFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># no of spatial dim.</span>
</div>
<div class="viewcode-block" id="WrapDiscreteData2Callable.__call__"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.WrapDiscreteData2Callable.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># allow more arguments (typically time) after spatial pos.:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndims</span><span class="p">]</span>
        <span class="c"># args can be tuple of scalars (point) or tuple of vectors</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolating_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># args is tuple of vectors; Interpolation must work</span>
            <span class="c"># with one point at a time:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolating_function</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c"># wrap in numpy array</span>

</div></div>
<div class="viewcode-block" id="wrap2callable"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.wrap2callable">[docs]</a><span class="k">def</span> <span class="nf">wrap2callable</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Allow constants, string formulas, discrete data points,</span>
<span class="sd">    user-defined functions and (callable) classes to be wrapped</span>
<span class="sd">    in a new callable function. That is, all the mentioned data</span>
<span class="sd">    structures can be used as a function, usually of space and/or</span>
<span class="sd">    time.</span>
<span class="sd">    (kwargs is used for string formulas)</span>

<span class="sd">    &gt;&gt;&gt; f1 = wrap2callable(2.0)</span>
<span class="sd">    &gt;&gt;&gt; f1(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; f2 = wrap2callable(&#39;1+2*x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f2(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; f3 = wrap2callable(&#39;1+2*t&#39;, independent_variable=&#39;t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f3(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; f4 = wrap2callable(&#39;a+b*t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f4(0.5)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    NameError: name &#39;a&#39; is not defined</span>
<span class="sd">    &gt;&gt;&gt; f4 = wrap2callable(&#39;a+b*t&#39;, independent_variable=&#39;t&#39;, a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; f4(0.5)</span>
<span class="sd">    2.0</span>

<span class="sd">    &gt;&gt;&gt; x = linspace(0, 1, 3); y=1+2*x</span>
<span class="sd">    &gt;&gt;&gt; f5 = wrap2callable((x,y))</span>
<span class="sd">    &gt;&gt;&gt; f5(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; def myfunc(x):  return 1+2*x</span>
<span class="sd">    &gt;&gt;&gt; f6 = wrap2callable(myfunc)</span>
<span class="sd">    &gt;&gt;&gt; f6(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; f7 = wrap2callable(lambda x: 1+2*x)</span>
<span class="sd">    &gt;&gt;&gt; f7(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; class MyClass:</span>
<span class="sd">            &#39;Representation of a function f(x; a, b) =a + b*x&#39;</span>
<span class="sd">            def __init__(self, a=1, b=1):</span>
<span class="sd">                self.a = a;  self.b = b</span>
<span class="sd">            def __call__(self, x):</span>
<span class="sd">                return self.a + self.b*x</span>
<span class="sd">    &gt;&gt;&gt; myclass = MyClass(a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; f8 = wrap2callable(myclass)</span>
<span class="sd">    &gt;&gt;&gt; f8(0.5)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; # 3D functions:</span>
<span class="sd">    &gt;&gt;&gt; f9 = wrap2callable(&#39;1+2*x+3*y+4*z&#39;, independent_variables=(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;))</span>
<span class="sd">    &gt;&gt;&gt; f9(0.5,1/3.,0.25)</span>
<span class="sd">    4.0</span>
<span class="sd">    &gt;&gt;&gt; # discrete 3D data:</span>
<span class="sd">    &gt;&gt;&gt; y = linspace(0, 1, 3); z = linspace(-1, 0.5, 16)</span>
<span class="sd">    &gt;&gt;&gt; xv = reshape(x, (len(x),1,1))</span>
<span class="sd">    &gt;&gt;&gt; yv = reshape(y, (1,len(y),1))</span>
<span class="sd">    &gt;&gt;&gt; zv = reshape(z, (1,1,len(z)))</span>
<span class="sd">    &gt;&gt;&gt; def myfunc3(x,y,z):  return 1+2*x+3*y+4*z</span>

<span class="sd">    &gt;&gt;&gt; values = myfunc3(xv, yv, zv)</span>
<span class="sd">    &gt;&gt;&gt; f10 = wrap2callable((x, y, z, values))</span>
<span class="sd">    &gt;&gt;&gt; f10(0.5, 1/3., 0.25)</span>
<span class="sd">    4.0</span>

<span class="sd">    One can also check what the object is wrapped as and do more</span>
<span class="sd">    specific operations, e.g.,</span>

<span class="sd">    &gt;&gt;&gt; f9.__class__.__name__</span>
<span class="sd">    &#39;StringFunction&#39;</span>
<span class="sd">    &gt;&gt;&gt; str(f9)     # look at function formula</span>
<span class="sd">    &#39;1+2*x+3*y+4*z&#39;</span>
<span class="sd">    &gt;&gt;&gt; f8.__class__.__name__</span>
<span class="sd">    &#39;MyClass&#39;</span>
<span class="sd">    &gt;&gt;&gt; f8.a, f8.b  # access MyClass-specific data</span>
<span class="sd">    (1, 2)</span>

<span class="sd">    Troubleshooting regarding string functions:</span>
<span class="sd">    If you use a string formula with a numpy array, you typically get</span>
<span class="sd">    error messages like::</span>

<span class="sd">       TypeError: only rank-0 arrays can be converted to Python scalars.</span>

<span class="sd">    You must then make the right import (numpy is recommended)::</span>

<span class="sd">       from Numeric/numarray/numpy/scitools.numpytools import *</span>

<span class="sd">    in the calling code and supply the keyword argument::</span>

<span class="sd">       globals=globals()</span>

<span class="sd">    to wrap2callable. See also the documentation of class StringFunction</span>
<span class="sd">    for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># this is a considerable optimization (up to a factor of 3),</span>
        <span class="c"># but then the additional info in the StringFunction instance</span>
        <span class="c"># is lost in the calling code:</span>
        <span class="c"># return StringFunction(f, **kwargs).__call__</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">WrapNo2Callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">WrapDiscreteData2Callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;f of type </span><span class="si">%s</span><span class="s"> is not callable&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>


<span class="c"># problem: setitem in ArrayGen does not support multiple indices</span>
<span class="c"># relying on inherited __setitem__ works fine</span>
</div>
<div class="viewcode-block" id="NumPy_array_iterator"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.NumPy_array_iterator">[docs]</a><span class="k">def</span> <span class="nf">NumPy_array_iterator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterate over all elements in a numpy array a.</span>
<span class="sd">    Two return values: a generator function and the code of this function.</span>
<span class="sd">    The ``numpy.ndenumerate`` iterator performs the same iteration over</span>
<span class="sd">    an array, but ``NumPy_array_iterator`` has some additional features</span>
<span class="sd">    (especially handy for coding finite difference stencils, see next</span>
<span class="sd">    paragraph).</span>

<span class="sd">    The keyword arguments specify offsets in the start and stop value</span>
<span class="sd">    of the index in each dimension. Legal argument names are</span>
<span class="sd">    ``offset0_start``, ``offset0_stop``, ``offset1_start``,</span>
<span class="sd">    ``offset1_stop``, etc.  Also ``offset_start`` and ``offset_stop``</span>
<span class="sd">    are legal keyword arguments, these imply the same offset value for</span>
<span class="sd">    all dimensions.</span>

<span class="sd">    Another keyword argument is ``no_value``, which can be True or False.</span>
<span class="sd">    If the value is True, the iterator returns the indices as a tuple,</span>
<span class="sd">    otherwise (default) the iterator returns a two-tuple consisting of</span>
<span class="sd">    the value of the array and the corresponding indices (as a tuple).</span>

<span class="sd">    Examples::</span>

<span class="sd">    &gt;&gt;&gt; q = linspace(1, 2*3*4, 2*3*4);  q.shape = (2,3,4)</span>
<span class="sd">    &gt;&gt;&gt; it, code = NumPy_array_iterator(q)</span>

<span class="sd">    &gt;&gt;&gt; print code  # generator function with 3 nested loops:</span>
<span class="sd">    def nested_loops(a):</span>
<span class="sd">        for i0 in xrange(0, a.shape[0]-0):</span>
<span class="sd">            for i1 in xrange(0, a.shape[1]-0):</span>
<span class="sd">                for i2 in xrange(0, a.shape[2]-0):</span>
<span class="sd">                    yield a[i0, i1, i2], (i0, i1, i2)</span>

<span class="sd">    &gt;&gt;&gt; type(it)</span>
<span class="sd">    &lt;type &#39;function&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; for value, index in it(q):</span>
<span class="sd">    ...     print &#39;a%s = %g&#39; % (index, value)</span>
<span class="sd">    ...</span>
<span class="sd">    a(0, 0, 0) = 1</span>
<span class="sd">    a(0, 0, 1) = 2</span>
<span class="sd">    a(0, 0, 2) = 3</span>
<span class="sd">    a(0, 0, 3) = 4</span>
<span class="sd">    a(0, 1, 0) = 5</span>
<span class="sd">    a(0, 1, 1) = 6</span>
<span class="sd">    a(0, 1, 2) = 7</span>
<span class="sd">    a(0, 1, 3) = 8</span>
<span class="sd">    a(0, 2, 0) = 9</span>
<span class="sd">    a(0, 2, 1) = 10</span>
<span class="sd">    a(0, 2, 2) = 11</span>
<span class="sd">    a(0, 2, 3) = 12</span>
<span class="sd">    a(1, 0, 0) = 13</span>
<span class="sd">    a(1, 0, 1) = 14</span>
<span class="sd">    a(1, 0, 2) = 15</span>
<span class="sd">    a(1, 0, 3) = 16</span>
<span class="sd">    a(1, 1, 0) = 17</span>
<span class="sd">    a(1, 1, 1) = 18</span>
<span class="sd">    a(1, 1, 2) = 19</span>
<span class="sd">    a(1, 1, 3) = 20</span>
<span class="sd">    a(1, 2, 0) = 21</span>
<span class="sd">    a(1, 2, 1) = 22</span>
<span class="sd">    a(1, 2, 2) = 23</span>
<span class="sd">    a(1, 2, 3) = 24</span>

<span class="sd">    Here is the version where only the indices and no the values</span>
<span class="sd">    are returned by the iterator::</span>

<span class="sd">    &gt;&gt;&gt; q = linspace(1, 1*3, 3);  q.shape = (1,3)</span>
<span class="sd">    &gt;&gt;&gt; it, code = NumPy_array_iterator(q, no_value=True)</span>

<span class="sd">    &gt;&gt;&gt; print code</span>
<span class="sd">    def nested_loops(a):</span>
<span class="sd">        for i0 in xrange(0, a.shape[0]-0):</span>
<span class="sd">            for i1 in xrange(0, a.shape[1]-0):</span>
<span class="sd">                yield i0, i1</span>

<span class="sd">    &gt;&gt;&gt; for i,j in it(q):</span>
<span class="sd">    ...   print i,j</span>
<span class="sd">    0 0</span>
<span class="sd">    0 1</span>
<span class="sd">    0 2</span>


<span class="sd">    Now let us try some offsets::</span>

<span class="sd">    &gt;&gt;&gt; it, code = NumPy_array_iterator(q, offset1_stop=1, offset_start=1)</span>

<span class="sd">    &gt;&gt;&gt; print code</span>
<span class="sd">    def nested_loops(a):</span>
<span class="sd">        for i0 in xrange(1, a.shape[0]-0):</span>
<span class="sd">            for i1 in xrange(1, a.shape[1]-1):</span>
<span class="sd">                for i2 in xrange(1, a.shape[2]-0):</span>
<span class="sd">                    yield a[i0, i1, i2], (i0, i1, i2)</span>

<span class="sd">    &gt;&gt;&gt; # note: the offsets appear in the xrange arguments</span>
<span class="sd">    &gt;&gt;&gt; for value, index in it(q):</span>
<span class="sd">    ...     print &#39;a%s = %g&#39; % (index, value)</span>
<span class="sd">    ...</span>
<span class="sd">    a(1, 1, 1) = 18</span>
<span class="sd">    a(1, 1, 2) = 19</span>
<span class="sd">    a(1, 1, 3) = 20</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># build the code of the generator function in a text string</span>
    <span class="c"># (since the number of nested loops needed to iterate over all</span>
    <span class="c"># elements are parameterized through len(a.shape))</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">offset_code1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_start=0&#39;</span> <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
    <span class="n">offset_code2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_stop=0&#39;</span>  <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
        <span class="n">key1</span> <span class="o">=</span> <span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_start&#39;</span> <span class="o">%</span> <span class="n">d</span>
        <span class="n">key2</span> <span class="o">=</span> <span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_stop&#39;</span> <span class="o">%</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">offset_code1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key1</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">offset_code2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key2</span> <span class="o">+</span> <span class="s">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key2</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;offset_start&#39;</span><span class="p">:</span>
            <span class="n">offset_code1</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_start=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> \
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))])</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;offset_stop&#39;</span><span class="p">:</span>
            <span class="n">offset_code2</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_stop=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> \
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))])</span>

    <span class="n">no_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;no_value&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">offset_code1</span><span class="p">:</span>
        <span class="k">exec</span> <span class="n">line</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">offset_code2</span><span class="p">:</span>
        <span class="k">exec</span> <span class="n">line</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s">&#39;def nested_loops(a):</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">indentation</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">*</span><span class="mi">4</span>
    <span class="n">indent</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="o">+</span> <span class="n">indentation</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="n">indent</span> <span class="o">+</span> \
        <span class="s">&#39;for i</span><span class="si">%d</span><span class="s"> in xrange(</span><span class="si">%d</span><span class="s">, a.shape[</span><span class="si">%d</span><span class="s">]-</span><span class="si">%d</span><span class="s">):</span><span class="se">\n</span><span class="s">&#39;</span> \
                <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_start&#39;</span> <span class="o">%</span> <span class="n">dim</span><span class="p">),</span>
                   <span class="n">dim</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;offset</span><span class="si">%d</span><span class="s">_stop&#39;</span> <span class="o">%</span> <span class="n">dim</span><span class="p">))</span>
        <span class="n">indent</span> <span class="o">+=</span> <span class="n">indentation</span>
    <span class="n">index</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;i</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))])</span>
    <span class="k">if</span> <span class="n">no_value</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="n">indent</span> <span class="o">+</span> <span class="s">&#39;yield &#39;</span> <span class="o">+</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="n">indent</span> <span class="o">+</span> <span class="s">&#39;yield &#39;</span> <span class="o">+</span> <span class="s">&#39;a[</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="n">index</span> <span class="o">+</span> <span class="s">&#39;, (&#39;</span> <span class="o">+</span> <span class="n">index</span> <span class="o">+</span> <span class="s">&#39;)&#39;</span>
    <span class="k">exec</span> <span class="n">code</span>
    <span class="k">return</span> <span class="n">nested_loops</span><span class="p">,</span> <span class="n">code</span>
</div>
<div class="viewcode-block" id="compute_histogram"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.compute_histogram">[docs]</a><span class="k">def</span> <span class="nf">compute_histogram</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a numpy array samples with random samples, this function</span>
<span class="sd">    returns the (x,y) arrays in a plot-ready version of the histogram.</span>
<span class="sd">    If piecewise_constant is True, the (x,y) arrays gives a piecewise</span>
<span class="sd">    constant curve when plotted, otherwise the (x,y) arrays gives a</span>
<span class="sd">    piecewise linear curve where the x coordinates coincide with the</span>
<span class="sd">    center points in each bin. The function makes use of</span>
<span class="sd">    numpy.lib.function_base.histogram with some additional code</span>
<span class="sd">    (for a piecewise curve or displaced x values to the centes of</span>
<span class="sd">    the bins).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="k">if</span> <span class="s">&#39;numpy&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># bin width</span>
    <span class="k">if</span> <span class="n">piecewise_constant</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

</div>
<div class="viewcode-block" id="factorial"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.factorial">[docs]</a><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;reduce&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the factorial n! using long integers (and pure Python code).</span>
<span class="sd">    Different implementations are available (see source code for</span>
<span class="sd">    implementation details).</span>

<span class="sd">    Note: The math module in Python 2.6 features a factorial</span>
<span class="sd">    function, making the present function redundant (except that</span>
<span class="sd">    the various pure Python implementations can be of interest</span>
<span class="sd">    for comparison).</span>

<span class="sd">    Here is an efficiency comparison of the methods (computing 80!):</span>

<span class="sd">    ==========================   =====================</span>
<span class="sd">            Method                Normalized CPU time</span>
<span class="sd">    ==========================   =====================</span>
<span class="sd">    reduce                             1.00</span>
<span class="sd">    lambda list comprehension          1.70</span>
<span class="sd">    lambda functional                  3.08</span>
<span class="sd">    plain recursive                    5.83</span>
<span class="sd">    lambda recursive                  21.73</span>
<span class="sd">    scipy                            131.18</span>
<span class="sd">    ==========================   =====================</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;factorial(n): n must be integer not </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">long</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;plain iterative&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;plain recursive&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;lambda recursive&#39;</span><span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">fc</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">long</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">fc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;lambda functional&#39;</span><span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> \
             <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="nb">long</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="nb">long</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;lambda list comprehension&#39;</span><span class="p">:</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> \
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">i</span><span class="p">]]</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;reduce&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;scipy&#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">scipy.misc.common</span> <span class="kn">as</span> <span class="nn">sc</span>
            <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;numpyutils.factorial: scipy is not available&#39;</span>
            <span class="k">print</span> <span class="s">&#39;default method=&quot;reduce&quot; is used instead&#39;</span>
            <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="c"># or return factorial(n)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;factorial: method=&quot;</span><span class="si">%s</span><span class="s">&quot; is not supported&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="asarray_cpwarn"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.asarray_cpwarn">[docs]</a><span class="k">def</span> <span class="nf">asarray_cpwarn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&#39;warning&#39;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    As asarray, but a warning or exception is issued if the</span>
<span class="sd">    a array is copied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_new</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c"># must drop numpy&#39;s order argument since it conflicts</span>
    <span class="c"># with Numeric&#39;s savespace</span>

    <span class="c"># did we copy?</span>
    <span class="k">if</span> <span class="n">a_new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
        <span class="c"># we do not return the identical array, i.e., copy has taken place</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">  copy of array </span><span class="si">%s</span><span class="s">, from </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
              <span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">a_new</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s">&#39;warning&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Warning: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">msg</span>
        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s">&#39;exception&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_new</span>

</div>
<div class="viewcode-block" id="seq"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.seq">[docs]</a><span class="k">def</span> <span class="nf">seq</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">return_type</span><span class="o">=</span><span class="s">&#39;NumPyArray&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate numbers from min to (and including!) max,</span>
<span class="sd">    with increment of inc. Safe alternative to arange.</span>
<span class="sd">    The return_type string governs the type of the returned</span>
<span class="sd">    sequence of numbers (&#39;NumPyArray&#39;, &#39;list&#39;, or &#39;tuple&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># allow sequence(3) to be 0., 1., 2., 3.</span>
        <span class="c"># take 1st arg as max, min as 0, and inc=1</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">;</span> <span class="nb">min</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">inc</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span> <span class="o">+</span> <span class="n">inc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s">&#39;NumPyArray&#39;</span> <span class="ow">or</span> <span class="n">return_type</span> <span class="o">==</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s">&#39;list&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s">&#39;tuple&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

</div>
<div class="viewcode-block" id="iseq"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.iseq">[docs]</a><span class="k">def</span> <span class="nf">iseq</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate integers from start to (and including) stop,</span>
<span class="sd">    with increment of inc. Alternative to range/xrange.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># allow isequence(3) to be 0, 1, 2, 3</span>
        <span class="c"># take 1st arg as stop, start as 0, and inc=1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">+</span><span class="n">inc</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
</div>
<span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span>  <span class="c"># backward compatibility</span>
<span class="n">isequence</span> <span class="o">=</span> <span class="n">iseq</span>  <span class="c"># backward compatibility</span>


<div class="viewcode-block" id="arr"><a class="viewcode-back" href="../../numpytools.html#scitools.numpytools.arr">[docs]</a><span class="k">def</span> <span class="nf">arr</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">element_type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">interval</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">file_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compact and flexible interface for creating numpy arrays,</span>
<span class="sd">    including several consistency and error checks.</span>

<span class="sd">     - *shape*: length of each dimension, tuple or int</span>
<span class="sd">     - *data*: list, tuple, or numpy array with data elements</span>
<span class="sd">     - *copy*: copy data if true, share data if false, boolean</span>
<span class="sd">     - *element_type*: float, int, int16, float64, bool, etc.</span>
<span class="sd">     - *interval*: make elements from a to b (shape gives no of elms), tuple or list</span>
<span class="sd">     - *file_*: filename or file object containing array data, string</span>
<span class="sd">     - *order*: &#39;Fortran&#39; or &#39;C&#39; storage, string</span>
<span class="sd">     - return value: created Numerical Python array</span>

<span class="sd">    The array can be created in four ways:</span>

<span class="sd">      1. as zeros (just shape specified),</span>

<span class="sd">      2. as uniformly spaced coordinates in an interval [a,b]</span>

<span class="sd">      3. as a copy of or reference to (depending on copy=True,False resp.)</span>
<span class="sd">         a list, tuple, or numpy array (provided as the data argument),</span>

<span class="sd">      4. from data in a file (for one- or two-dimensional real-valued arrays).</span>

<span class="sd">    The function calls the underlying numpy functions zeros, array and</span>
<span class="sd">    linspace (see the numpy manual for the functionality of these</span>
<span class="sd">    functions).  In case of data in a file, the first line determines</span>
<span class="sd">    the number of columns in the array. The file format is just rows</span>
<span class="sd">    and columns with numbers, no decorations (square brackets, commas,</span>
<span class="sd">    etc.) are allowed.</span>

<span class="sd">    &gt;&gt;&gt; arr((3,4))</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.]])</span>

<span class="sd">    &gt;&gt;&gt; arr(4, element_type=int) + 4  # integer array</span>
<span class="sd">    array([4, 4, 4, 4])</span>

<span class="sd">    &gt;&gt;&gt; arr(3, interval=[0,2])</span>
<span class="sd">    array([ 0.,  1.,  2.])</span>

<span class="sd">    &gt;&gt;&gt; somelist=[[0,1],[5,5]]</span>
<span class="sd">    &gt;&gt;&gt; a = arr(data=somelist)</span>
<span class="sd">    &gt;&gt;&gt; a  # a has always float elements by default</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 5.,  5.]])</span>
<span class="sd">    &gt;&gt;&gt; a = arr(data=somelist, element_type=int)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [5, 5]])</span>
<span class="sd">    &gt;&gt;&gt; b = a + 1</span>

<span class="sd">    &gt;&gt;&gt; c = arr(data=b, copy=False)  # let c share data with b</span>
<span class="sd">    &gt;&gt;&gt; b is c</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; id(b) == id(c)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; # make a file with array data:</span>
<span class="sd">    &gt;&gt;&gt; f = open(&#39;tmp.dat&#39;, &#39;w&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.write(&#39;&#39;&#39;\</span>
<span class="sd">    ... 1 3</span>
<span class="sd">    ... 2 6</span>
<span class="sd">    ... 3 12</span>
<span class="sd">    ... 3.5 20</span>
<span class="sd">    ... &#39;&#39;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.close()</span>
<span class="sd">    &gt;&gt;&gt; # read array data from file:</span>
<span class="sd">    &gt;&gt;&gt; a = arr(file_=&#39;tmp.dat&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[  1. ,   3. ],</span>
<span class="sd">           [  2. ,   6. ],</span>
<span class="sd">           [  3. ,  12. ],</span>
<span class="sd">           [  3.5,  20. ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">file_</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">isSequenceType</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arr: data argument is not a sequence type&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="c"># check that shape and data are compatible:</span>
            <span class="k">if</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;arr: shape=</span><span class="si">%s</span><span class="s"> is not compatible with </span><span class="si">%d</span><span class="s"> &#39;</span>\
                    <span class="s">&#39;elements in the provided data&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">size</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;arr: shape=</span><span class="si">%d</span><span class="s"> is not compatible with </span><span class="si">%d</span><span class="s"> &#39;</span>\
                    <span class="s">&#39;elements in the provided data&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">copy</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="c"># cannot share data (data is list/tuple)</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">element_type</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&#39;shape is </span><span class="si">%s</span><span class="s">, must be list/tuple or int&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">file_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="p">(</span><span class="nb">basestring</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span> <span class="n">StringIO</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s">&#39;file_ argument must be a string (filename) or &#39;</span>\
                <span class="s">&#39;open file object, not </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">file_</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="c"># skip blank lines:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">line1</span> <span class="o">=</span> <span class="n">file_</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line1</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">ncolumns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line1</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
        <span class="n">file_</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># we assume that array data in file has element_type=float:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">element_type</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="n">element_type</span> <span class="o">==</span> <span class="s">&#39;d&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;element_type must be float_/&quot;</span><span class="si">%s</span><span class="s">&quot;, not &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> \
                             <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">element_type</span><span class="p">))</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">file_</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c"># shape array d:</span>
        <span class="k">if</span> <span class="n">ncolumns</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">suggested_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">/</span><span class="n">ncolumns</span><span class="p">),</span> <span class="n">ncolumns</span><span class="p">)</span>
            <span class="n">total_size</span> <span class="o">=</span> <span class="n">suggested_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">suggested_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">total_size</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;found </span><span class="si">%d</span><span class="s"> array entries in file &quot;</span><span class="si">%s</span><span class="s">&quot;, but first line</span><span class="se">\n</span><span class="s">&#39;</span>\
                    <span class="s">&#39;contains </span><span class="si">%d</span><span class="s"> elements - no shape is compatible with</span><span class="se">\n</span><span class="s">&#39;</span>\
                    <span class="s">&#39;these values&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="nb">file</span><span class="p">,</span> <span class="n">ncolumns</span><span class="p">))</span>
            <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">suggested_shape</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;shape=</span><span class="si">%s</span><span class="s"> is not compatible with shape </span><span class="si">%s</span><span class="s"> found in &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">file</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">elif</span> <span class="n">interval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;For array values in an interval, &#39;</span>\
                            <span class="s">&#39;shape must be an integer&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;interval must be list or tuple, not </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                            <span class="nb">type</span><span class="p">(</span><span class="n">interval</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;interval must be a 2-tuple (or list)&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">linspace</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># print more information (size of data):</span>
            <span class="k">print</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;of size </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">shape</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># no data, no file, just make zeros</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;arr: shape (1st arg) must be tuple or int&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;arr: either shape, data, or from_function must be specified&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">element_type</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># print more information (size of data):</span>
            <span class="k">print</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;of size </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">shape</span>
</div>
<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>
    <span class="n">_test_FloatComparison</span><span class="p">()</span>
    <span class="c"># test norm functions for multi-dimensional arrays:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">27</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">norm_l2</span><span class="p">,</span> <span class="n">norm_L2</span><span class="p">,</span> <span class="n">norm_l1</span><span class="p">,</span> <span class="n">norm_L1</span><span class="p">,</span> <span class="n">norm_inf</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="mf">78.7464284904401239</span><span class="p">,</span> <span class="mf">15.1547572288924073</span><span class="p">,</span> <span class="mi">351</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">26</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">float_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> failed: result=</span><span class="si">%g</span><span class="s">, not </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">r</span><span class="p">)</span>

    <span class="c"># Gram-Schmidt:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">V1</span> <span class="o">=</span> <span class="n">Gram_Schmidt</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">V2</span> <span class="o">=</span> <span class="n">Gram_Schmidt1</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">float_eq</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span> <span class="n">V2</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;The two Gram_Schmidt versions did not give equal results&#39;</span>
        <span class="k">print</span> <span class="s">&#39;Gram_Schmidt:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">V1</span>
        <span class="k">print</span> <span class="s">&#39;Gram_Schmidt1:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">V2</span>

    <span class="c"># Null space:</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
    <span class="c">#K = random.random(3*7).reshape(7,3) # does not work...</span>
    <span class="k">print</span> <span class="s">&#39;K=</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">K</span>
    <span class="k">print</span> <span class="s">&#39;null(K)=</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">null</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">K</span><span class="o">*</span><span class="n">null</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;K*null(K):&#39;</span><span class="p">,</span> <span class="n">r</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="n">_test</span><span class="p">()</span>

<span class="c">#---- build doc string from _numpyload/util doc strings ----</span>

<span class="kn">import</span> <span class="nn">_numpyload</span> <span class="kn">as</span> <span class="nn">_load</span>
<span class="n">_load</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">+=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">Example on what gets imported</span>
<span class="s">-----------------------------</span>

<span class="s">(basic_NumPy holds the name of the Numeric</span>
<span class="s">Python module after import of numpytools (or _numpyload):</span>

<span class="s"># default:</span>
<span class="s">unix/DOS&gt; python -c &quot;from numpytools import *; print basic_NumPy&quot;</span>
<span class="s">numpy</span>

<span class="s"># set the NUMPYARRAY environment variable:</span>
<span class="s">unix/DOS&gt; python -c &quot;import os; os.environ[&#39;NUMPYARRAY&#39;]=&#39;Numeric&#39;; from numpytools import *; print basic_NumPy&quot;</span>
<span class="s">Numeric</span>

<span class="s"># import a Numerical Python module (precedence over NUMPYARRAY variable):</span>
<span class="s">unix/DOS&gt; python -c &quot;import numpy; import os; os.environ[&#39;NUMPYARRAY&#39;]=&#39;Numeric&#39;; from numpytools import *; print basic_NumPy&quot;</span>
<span class="s">numpy</span>

<span class="s"># add flag on the command line (precedence over import):</span>
<span class="s">unix/DOS&gt; python -c &quot;import numpy; import os; os.environ[&#39;NUMPYARRAY&#39;]=&#39;Numeric&#39;; from numpytools import *; print basic_NumPy&quot; --numarray</span>
<span class="s">numarray</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpyutils</span> <span class="kn">as</span> <span class="nn">_utils</span>
<span class="c"># insert numpyutils and _numpyload documentation into the</span>
<span class="c"># doc string of this numpytools module:</span>
<span class="n">__doc__</span> <span class="o">=</span> <span class="n">__doc__</span> <span class="o">%</span> <span class="p">(</span><span class="n">_load</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">_utils</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
<span class="c"># clean up:</span>
<span class="c"># import numpyutils may import numpy and we remove this entry</span>
<span class="c"># in sys.modules</span>
<span class="k">if</span> <span class="n">basic_NumPy</span> <span class="o">!=</span> <span class="s">&#39;numpy&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;numpy&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s">&#39;numpy&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">_load</span><span class="p">,</span> <span class="n">_utils</span>
<span class="c">#---------</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_doctest</span><span class="p">():</span>
        <span class="kn">import</span> <span class="nn">doctest</span><span class="o">,</span> <span class="nn">numpytools</span>
        <span class="k">return</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">numpytools</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">namecheck</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;fft&#39;</span><span class="p">,</span><span class="s">&#39;mlab&#39;</span><span class="p">,</span><span class="s">&#39;ma&#39;</span><span class="p">,</span><span class="s">&#39;ra&#39;</span><span class="p">,</span><span class="s">&#39;la&#39;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that some packages imported by numpytools </span>
<span class="sd">        works for Numeric, numarray, or numpy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Using </span><span class="si">%s</span><span class="s"> in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">basic_NumPy</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namecheck</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s"> : </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">N</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="nb">eval</span><span class="p">(</span><span class="s">&quot;N.</span><span class="si">%s</span><span class="s">.__name__&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">))</span>
        <span class="k">print</span> <span class="s">&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_test1</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Call verify function for N as Numeric, numarray, and numpy.&quot;&quot;&quot;</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;--Numeric&#39;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">numpytools</span> <span class="kn">as</span> <span class="nn">N</span>
        <span class="n">verify</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;--numarray&#39;</span>
        <span class="nb">reload</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">verify</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;--numpy&#39;</span>
        <span class="nb">reload</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">verify</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c">#_test1()</span>

    <span class="c">#test_ArrayGen()</span>
    <span class="c">#_doctest()  # does not work properly with wrap2callable</span>
    
    <span class="c"># Test meshgrid function</span>
    <span class="kn">import</span> <span class="nn">unittest</span>
    <span class="kn">import</span> <span class="nn">numpytools</span> <span class="kn">as</span> <span class="nn">N</span>

    <span class="k">class</span> <span class="nc">numpytoolsTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">testMeshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c">#print &#39;testing Meshgrid&#39;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">N</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="k">def</span> <span class="nf">testMeshgrid_DenseFromMixedArrayTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># Other combination of arrays</span>
            <span class="c">#print &#39;testing Meshgrid with mixed array implementations&#39;</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            
            <span class="kn">import</span> <span class="nn">Numeric</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">Numeric</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span>  <span class="n">N</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s">&quot;Meshgrid failed with arraytype mix of  Numeric and </span><span class="si">%s</span><span class="s">&quot;</span>\
                    <span class="o">%</span><span class="n">N</span><span class="o">.</span><span class="n">basic_NumPy</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">numarray</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numarray</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span>  <span class="n">N</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s">&quot;Meshgrid failed with arraytype mix of numarray and </span><span class="si">%s</span><span class="s">&quot;</span>\
                    <span class="o">%</span><span class="n">N</span><span class="o">.</span><span class="n">basic_NumPy</span><span class="p">)</span>

            <span class="kn">import</span> <span class="nn">numpy</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="c">#assert N.rank(X) == 3</span>
            <span class="k">if</span> <span class="ow">not</span>  <span class="n">N</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s">&quot;Meshgrid failed with arraytype mix of numpy and </span><span class="si">%s</span><span class="s">&quot;</span>\
                    <span class="o">%</span><span class="n">N</span><span class="o">.</span><span class="n">basic_NumPy</span><span class="p">)</span>
            
        <span class="k">def</span> <span class="nf">testMeshGrid_DenseFromNodenseMeshgridOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># sparse fails for dense output when input has singleton dimensions</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">seq</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">seq</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="c"># xx and yy now has singleton dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">rank</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">rank</span><span class="p">(</span><span class="n">yy</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">yy</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">yy</span><span class="p">))</span>
            <span class="c"># This one should fail when xx and yy is not flat as well</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">yy</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c"># no singleton</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">yy</span><span class="p">),</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="c"># Add singleton dimensions</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">yy</span><span class="p">),</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

            <span class="c">#from IPython.Shell import IPythonShellEmbed as magic</span>
            <span class="c">#magic()(&#39;from unittest&#39;)</span>
            
    <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>  <span class="c"># extra argument for the test below</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;--Numeric&#39;</span><span class="p">,</span> <span class="s">&#39;--numarray&#39;</span><span class="p">,</span> <span class="s">&#39;--numpy&#39;</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">__import__</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;You don&#39;t have </span><span class="si">%s</span><span class="s"> installed&quot;</span> <span class="o">%</span><span class="n">arg</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">continue</span>
        
        <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Now testing with system arg </span><span class="si">%10s</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="o">*</span><span class="mi">38</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">N</span><span class="p">,</span> <span class="nb">dir</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="nb">reload</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>  <span class="n">verify</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">makeSuite</span><span class="p">(</span><span class="n">numpytoolsTest</span><span class="p">)</span>
        <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/scitools_logo.jpg" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">SciTools 0.9.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, H. P. Langtangen, J. Ring, ++.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>